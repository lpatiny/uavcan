{
  "1": {
    "description": "This message is used for dynamic Node ID allocation.\nWhen a node needs to request a node ID dynamically, it will transmit an anonymous message transfer of this type.\nIn order to reduce probability of CAN ID collisions when multiple nodes are publishing this request, the CAN ID\nfield of anonymous message transfer includes a Discriminator, which is a special field that has to be filled with\nrandom data by the transmitting node. Since Discriminator collisions are likely to happen (probability approx.\n0.006%), nodes that are requesting dynamic allocations need to be able to handle them correctly. Hence, a collision\nresolution protocol is defined (alike CSMA/CD). The collision resolution protocol is based on two randomized\ntransmission intervals:\n- Request period - Trequest.\n- Follow up delay - Tfollowup.\nRecommended randomization ranges for these intervals are documented in the constants of this message type (see below).\nRandom intervals must be chosen anew per transmission, whereas the Discriminator value is allowed to stay constant\nper node.\nIn the below description the following terms are used:\n- Allocator - the node that serves allocation requests.\n- Allocatee - the node that requests an allocation from the Allocator.\nThe response timeout is not explicitly defined for this protocol, as the Allocatee will request the allocation\nTrequest units of time later again, unless the allocation has been granted. Despite this, the implementation can\nconsider the value of FOLLOWUP_TIMEOUT_MS as an allocation timeout, if necessary.\nOn the allocatee's side the protocol is defined through the following set of rules:\nRule A. On initialization:\n1. The allocatee subscribes to this message.\n2. The allocatee starts the Request Timer with a random interval of Trequest.\nRule B. On expiration of Request Timer:\n1. Request Timer restarts with a random interval of Trequest.\n2. The allocatee broadcasts a first-stage Allocation request message, where the fields are assigned following values:\n   node_id                 - preferred node ID, or zero if the allocatee doesn't have any preference\n   first_part_of_unique_id - true\n   unique_id               - first MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST bytes of unique ID\nRule C. On any Allocation message, even if other rules also match:\n1. Request Timer restarts with a random interval of Trequest.\nRule D. On an Allocation message WHERE (source node ID is non-anonymous) AND (allocatee's unique ID starts with the\nbytes available in the field unique_id) AND (unique_id is less than 16 bytes long):\n1. The allocatee waits for Tfollowup units of time, while listening for other Allocation messages. If an Allocation\n   message is received during this time, the execution of this rule will be terminated. Also see rule C.\n2. The allocatee broadcasts a second-stage Allocation request message, where the fields are assigned following values:\n   node_id                 - same value as in the first-stage\n   first_part_of_unique_id - false\n   unique_id               - at most MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST bytes of local unique ID with an offset\n                             equal to number of bytes in the received unique ID\nRule E. On an Allocation message WHERE (source node ID is non-anonymous) AND (unique_id fully matches allocatee's\nunique ID) AND (node_id in the received message is not zero):\n1. Request Timer stops.\n2. The allocatee initializes its node_id with the received value.\n3. The allocatee terminates subscription to Allocation messages.\n4. Exit.\nRecommended randomization range for request period.\nThese definitions have an advisory status; it is OK to pick higher values for both bounds, as it won't affect\nprotocol compatibility. In fact, it is advised to pick higher values if the target application is not concerned\nabout the time it will spend on completing the dynamic node ID allocation procedure, as it will reduce\ninterference with other nodes, possibly of higher importance.\nThe lower bound shall not be lower than FOLLOWUP_TIMEOUT_MS, otherwise the request may conflict with a followup.\nRecommended randomization range for followup delay.\nThe upper bound shall not exceed FOLLOWUP_TIMEOUT_MS, because the allocator will reset the state on its end.\nAllocator will reset its state if there was no follow-up request in this amount of time.\nAny request message can accommodate no more than this number of bytes of unique ID.\nThis limitation is needed to ensure that all request transfers are single-frame.\nThis limitation does not apply to CAN FD transport.\nWhen requesting an allocation, set the field 'node_id' to this value if there's no preference.\nIf transfer is anonymous, this is the preferred ID.\nIf transfer is non-anonymous, this is allocated ID.\nIf the allocatee does not have any preference, this value must be set to zero. In this case, the allocator\nmust choose the highest unused node ID value for this allocation (except 126 and 127, that are reserved for\nnetwork maintenance tools). E.g., if the allocation table is empty and the node has requested an allocation\nwithout any preference, the allocator will grant the node ID 125.\nIf the preferred node ID is not zero, the allocator will traverse the allocation table starting from the\npreferred node ID upward, until a free node ID is found. If a free node ID could not be found, the\nallocator will restart the search from the preferred node ID downward, until a free node ID is found.\nIn pseudocode:\n  int findFreeNodeID(const int preferred)\n  {\n      // Search up\n      int candidate = (preferred > 0) ? preferred : 125;\n      while (candidate <= 125)\n      {\n          if (!isOccupied(candidate))\n              return candidate;\n          candidate++;\n      }\n      // Search down\n      candidate = (preferred > 0) ? preferred : 125;\n      while (candidate > 0)\n      {\n          if (!isOccupied(candidate))\n              return candidate;\n          candidate--;\n      }\n      // Not found\n      return -1;\n  }\nIf transfer is anonymous, this field indicates first-stage request.\nIf transfer is non-anonymous, this field should be assigned zero and ignored.\nIf transfer is anonymous, this array must not contain more than MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST items.\nNote that array is tail-optimized, i.e. it will not be prepended with length field.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "nodeId",
        "description": ""
      },
      {
        "length": 16,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "uniqueId",
        "description": ""
      }
    ],
    "statics": [
      "uint16 MAX_REQUEST_PERIOD_MS = 1000     # It is OK to exceed this value",
      "uint16 MIN_REQUEST_PERIOD_MS = 600      # It is OK to exceed this value",
      "uint16 MAX_FOLLOWUP_DELAY_MS = 400",
      "uint16 MIN_FOLLOWUP_DELAY_MS = 0        # Defined only for regularity; will always be zero.",
      "uint16 FOLLOWUP_TIMEOUT_MS = 500",
      "uint8 MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST = 6",
      "uint7 ANY_NODE_ID = 0"
    ]
  },
  "2": {
    "description": "Get the implementation details of a given data type.\nRequest is interpreted as follows:\n - If the field 'name' is empty, the fields 'kind' and 'id' will be used to identify the data type.\n - If the field 'name' is non-empty, it will be used to identify the data type; the\n   fields 'kind' and 'id' will be ignored.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 16,
        "name": "id",
        "description": "Ignored if 'name' is non-empty"
      },
      {
        "length": 80,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "name",
        "description": "Full data type name, e.g. \"uavcan.protocol.GetDataTypeInfo\""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 64,
        "name": "signature",
        "description": "Data type signature; valid only if the data type is known (see FLAG_KNOWN)"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 16,
        "name": "id",
        "description": "Valid only if the data type is known (see FLAG_KNOWN)"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "flags",
        "description": ""
      },
      {
        "length": 80,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "name",
        "description": "Full data type name"
      }
    ],
    "statics": [
      "uint8 FLAG_KNOWN      = 1   # This data type is defined",
      "uint8 FLAG_SUBSCRIBED = 2   # Subscribed to messages of this type",
      "uint8 FLAG_PUBLISHING = 4   # Publishing messages of this type",
      "uint8 FLAG_SERVING    = 8   # Providing service of this type"
    ]
  },
  "4": {
    "description": "Global time synchronization.\nAny node that publishes timestamped data must use this time reference.\nPlease refer to the specification to learn about the synchronization algorithm.\nBroadcasting period must be within this range.\nSynchronization slaves may switch to a new source if the current master was silent for this amount of time.\nTime in microseconds when the PREVIOUS GlobalTimeSync message was transmitted.\nIf this message is the first one, this field must be zero.",
    "variables": [],
    "statics": [
      "uint16 MAX_BROADCASTING_PERIOD_MS = 1100            # Milliseconds",
      "uint16 MIN_BROADCASTING_PERIOD_MS = 40              # Milliseconds",
      "uint16 RECOMMENDED_BROADCASTER_TIMEOUT_MS = 2200    # Milliseconds"
    ]
  },
  "5": {
    "description": "Restart the node.\nSome nodes may require restart before the new configuration will be applied.\nThe request should be rejected if magic_number does not equal MAGIC_NUMBER.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 40,
        "name": "magicNumber",
        "description": ""
      }
    ],
    "statics": [
      "uint40 MAGIC_NUMBER = 0xACCE551B1E"
    ]
  },
  "6": {
    "description": "THIS DEFINITION IS SUBJECT TO CHANGE.\nThis service allows to execute arbitrary commands on the remote node's internal system shell.\nEssentially, this service mimics a typical terminal emulator, with one text input (stdin) and two text\noutputs (stdout and stderr). When there's no process running, the input is directed into the terminal\nhandler itself, which interprets it. If there's a process running, the input will be directed into\nstdin of the running process. It is possible to forcefully return the terminal into a known state by\nmeans of setting the reset flag (see below), in which case the terminal will kill all of the child\nprocesses, if any, and return into the initial idle state.\nThe server is assumed to allocate one independent terminal instance per client, so that different clients\ncan execute commands without interfering with each other.\nInput and output should use this newline character.\nThe server is required to keep the result of the last executed command for at least this time.\nWhen this time expires, the server may remove the results in order to reclaim the memory, but it\nis not guaranteed. Hence, the clients must retrieve the results in this amount of time.\nThese flags control the shell and command execution.\nIf the shell is idle, it will interpret this string.\nIf there's a process running, this string will be piped into its stdin.\nIf RESET_SHELL is set, new input will be interpreted by the shell immediately.\nExit status of the last executed process, or error code of the shell itself.\nDefault value is zero.\nThese flags indicate the status of the shell.\nIn case of a shell error, this string may contain ASCII string explaining the nature of the error.\nOtherwise, if stdout read is requested, this string will contain stdout data. If stderr read is requested,\nthis string will contain stderr data. If both stdout and stderr read is requested, this string will start\nwith stdout and end with stderr, with no separator in between.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "flags",
        "description": ""
      },
      {
        "length": 128,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "input",
        "description": ""
      },
      {
        "kind": "int",
        "bits": 32,
        "name": "lastExitStatus",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "flags",
        "description": ""
      },
      {
        "length": 256,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "output",
        "description": ""
      }
    ],
    "statics": [
      "uint8 NEWLINE = '\\n'",
      "uint8 MIN_OUTPUT_LIFETIME_SEC = 10",
      "uint8 FLAG_RESET_SHELL          = 1     # Restarts the shell instance anew; may or may not imply CLEAR_OUTPUT_BUFFERS",
      "uint8 FLAG_CLEAR_OUTPUT_BUFFERS = 2     # Makes stdout and stderr buffers empty",
      "uint8 FLAG_READ_STDOUT          = 64    # Output will contain stdout",
      "uint8 FLAG_READ_STDERR          = 128   # Output will be extended with stderr",
      "uint8 FLAG_RUNNING              = 1     # The shell is currently running a process; stdin/out/err are piped to it",
      "uint8 FLAG_SHELL_ERROR          = 2     # Exit status contains error code, output contains text (e.g. no such command)",
      "uint8 FLAG_HAS_PENDING_STDOUT   = 64    # There is more stdout to read",
      "uint8 FLAG_HAS_PENDING_STDERR   = 128   # There is more stderr to read"
    ]
  },
  "10": {
    "description": "Service to control the node configuration.\nSAVE operation instructs the remote node to save the current configuration parameters into a non-volatile\nstorage. The node may require a restart in order for some changes to take effect.\nERASE operation instructs the remote node to clear its configuration storage and reinitialize the parameters\nwith their default values. The node may require a restart in order for some changes to take effect.\nOther opcodes may be added in the future (for example, an opcode for switching between multiple configurations).\nReserved, keep zero.\nIf 'ok' (the field below) is true, this value is not used and must be kept zero.\nIf 'ok' is false, this value may contain error code. Error code constants may be defined in the future.\nTrue if the operation has been performed successfully, false otherwise.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "opcode",
        "description": ""
      },
      {
        "kind": "int",
        "bits": 48,
        "name": "argument",
        "description": ""
      },
      {
        "kind": "int",
        "bits": 48,
        "name": "argument",
        "description": ""
      }
    ],
    "statics": [
      "uint8 OPCODE_SAVE  = 0  # Save all parameters to non-volatile storage.",
      "uint8 OPCODE_ERASE = 1  # Clear the non-volatile storage; some changes may take effect only after reboot."
    ]
  },
  "11": {
    "description": "Get or set a parameter by name or by index.\nNote that access by index should only be used to retrieve the list of parameters; it is highly\ndiscouraged to use it for anything else, because persistent ordering is not guaranteed.\nIndex of the parameter starting from 0; ignored if name is nonempty.\nUse index only to retrieve the list of parameters.\nParameter ordering must be well defined (e.g. alphabetical, or any other stable ordering),\nin order for the index access to work.\nIf set - parameter will be assigned this value, then the new value will be returned.\nIf not set - current parameter value will be returned.\nRefer to the definition of Value for details.\nName of the parameter; always preferred over index if nonempty.\nActual parameter value.\nFor set requests, it should contain the actual parameter value after the set request was\nexecuted. The objective is to let the client know if the value could not be updated, e.g.\ndue to its range violation, etc.\nEmpty value (and/or empty name) indicates that there is no such parameter.\nEmpty name (and/or empty value) in response indicates that there is no such parameter.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 13,
        "name": "index",
        "description": ""
      },
      {
        "length": 92,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "name",
        "description": ""
      },
      {
        "length": 92,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "name",
        "description": ""
      }
    ],
    "statics": []
  },
  "15": {
    "description": "This service instructs the node to begin the process of automated enumeration.\nThe node will automatically leave enumeration mode upon expiration of this timeout.\nName of the parameter to enumerate, e.g. ESC index.\nIf the name is left empty, the node will infer the parameter name automatically (autodetect).\nIt is highly recommended to always use autodetection in order to avoid dependency on hard-coded parameter names,\nand also allow the enumeratee to possibly enumerate multiple different parameters at once.\nThe rule of thumb is to always leave this parameter empty unless you really know what you're doing.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 16,
        "name": "timeoutSec",
        "description": "[Seconds]"
      },
      {
        "length": 92,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "parameterName",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "error",
        "description": ""
      }
    ],
    "statics": [
      "uint16 TIMEOUT_CANCEL   = 0     # Stop enumeration immediately",
      "uint16 TIMEOUT_INFINITE = 65535 # Do not stop until explicitly requested",
      "uint8 ERROR_OK                  = 0     # Success",
      "uint8 ERROR_INVALID_MODE        = 1     # The node cannot perform enumeration in its current operating mode",
      "uint8 ERROR_INVALID_PARAMETER   = 2     # The node cannot enumerate on the requested parameter, or it doesn't exist",
      "uint8 ERROR_UNSUPPORTED         = 3     # The node cannot perform enumeration in its current configuration",
      "uint8 ERROR_UNKNOWN             = 255   # Generic error"
    ]
  },
  "30": {
    "description": "THIS DEFINITION IS SUBJECT TO CHANGE.\nThis type is a part of the Raft consensus algorithm.\nPlease refer to the specification for details.\nGiven min election timeout and cluster size, the maximum recommended request interval can be derived as follows:\n  max recommended request interval = (min election timeout) / 2 requests / (cluster size - 1)\nThe equation assumes that the Leader requests one Follower at a time, so that there's at most one pending call\nat any moment. Such behavior is optimal as it creates uniform bus load, but it is actually implementation-specific.\nObviously, request interval can be lower than that if needed, but higher values are not recommended as they may\ncause Followers to initiate premature elections in case of intensive frame losses or delays.\nReal timeout is randomized in the range (MIN, MAX], according to the Raft paper.\nRefer to the Raft paper for explanation.\nWorst-case replication time per Follower can be computed as:\n  worst replication time = (127 log entries) * (2 trips of next_index) * (request interval per Follower)\nRefer to the Raft paper for explanation.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "term",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "prevLogTerm",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "prevLogIndex",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "leaderCommit",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "term",
        "description": ""
      }
    ],
    "statics": [
      "uint16 DEFAULT_MIN_ELECTION_TIMEOUT_MS = 2000",
      "uint16 DEFAULT_MAX_ELECTION_TIMEOUT_MS = 4000"
    ]
  },
  "31": {
    "description": "THIS DEFINITION IS SUBJECT TO CHANGE.\nThis type is a part of the Raft consensus algorithm.\nPlease refer to the specification for details.\nRefer to the Raft paper for explanation.\nRefer to the Raft paper for explanation.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "term",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "lastLogTerm",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "lastLogIndex",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "term",
        "description": ""
      }
    ],
    "statics": []
  },
  "40": {
    "description": "This service initiates firmware update on a remote node.\nThe node that is being updated (slave) will retrieve the firmware image file 'image_file_remote_path' from the node\n'source_node_id' using the file read service, then it will update the firmware and reboot.\nThe slave can explicitly reject this request if it is not possible to update the firmware at the moment\n(e.g. if the node is busy).\nIf the slave node accepts this request, the initiator will get a response immediately, before the update process\nactually begins.\nWhile the firmware is being updated, the slave should set its mode (uavcan.protocol.NodeStatus.mode) to\nMODE_SOFTWARE_UPDATE.\nOther error codes may be added in the future.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "sourceNodeId",
        "description": "If this field is zero, the caller's Node ID will be used instead."
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "error",
        "description": ""
      },
      {
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "optionalErrorMessage",
        "description": "Detailed description of the error."
      }
    ],
    "statics": [
      "uint8 ERROR_OK               = 0",
      "uint8 ERROR_INVALID_MODE     = 1    # Cannot perform the update in the current operating mode or state.",
      "uint8 ERROR_IN_PROGRESS      = 2    # Firmware update is already in progress, and the slave doesn't want to restart.",
      "uint8 ERROR_UNKNOWN          = 255"
    ]
  },
  "45": {
    "description": "Request info about a remote file system entry (file, directory, etc).\nFile size in bytes.\nShould be set to zero for directories.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 40,
        "name": "size",
        "description": ""
      }
    ],
    "statics": []
  },
  "46": {
    "description": "This service can be used to retrieve a remote directory listing, one entry per request.\nThe client should query each entry independently, iterating 'entry_index' from 0 until the last entry is passed,\nin which case the server will report that there is no such entry (via the fields 'entry_type' and 'error').\nThe entry_index shall be applied to the ordered list of directory entries (e.g. alphabetically ordered). The exact\nsorting criteria does not matter as long as it provides the same ordering for subsequent service calls.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "entryIndex",
        "description": ""
      }
    ],
    "statics": []
  },
  "47": {
    "description": "Delete remote file system entry.\nIf the remote entry is a directory, all nested entries will be removed too.",
    "variables": [],
    "statics": []
  },
  "48": {
    "description": "Read file from a remote node.\n\nThere are two possible outcomes of a successful service call:\n 1. Data array size equals its capacity. This means that the end of the file is not reached yet.\n 2. Data array size is less than its capacity, possibly zero. This means that the end of file is reached.\n\nThus, if the client needs to fetch the entire file, it should repeatedly call this service while increasing the\noffset, until incomplete data is returned.\nIf the object pointed by 'path' cannot be read (e.g. it is a directory or it does not exist), appropriate error code\nwill be returned, and data array will be empty.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 40,
        "name": "offset",
        "description": ""
      },
      {
        "length": 256,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "data",
        "description": ""
      }
    ],
    "statics": []
  },
  "49": {
    "description": "Write into a remote file.\nThe server shall place the contents of the field 'data' into the file pointed by 'path' at the offset specified by\nthe field 'offset'.\nWhen writing a file, the client should repeatedly call this service with data while advancing offset until the file\nis written completely. When write is complete, the client shall call the service one last time, with the offset\nset to the size of the file and with the data field empty, which will signal the server that the write operation is\ncomplete.\nWhen the write operation is complete, the server shall truncate the resulting file past the specified offset.\nServer implementation advice:\nIt is recommended to implement proper handling of concurrent writes to the same file from different clients, for\nexample by means of creating a staging area for uncompleted writes (like FTP servers do).",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 40,
        "name": "offset",
        "description": ""
      },
      {
        "length": 192,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "data",
        "description": ""
      }
    ],
    "statics": []
  },
  "63": {
    "description": "This service carries arbitrary data in the format of the specified high-level protocol.\nThe data will be delivered to the specified node only (not broadcast), and the addressed node\nwill be required to respond (although the response may be empty, if the chosen protocol allows so).\nThe specified protocol applies both to the request and to the response. The channelID allows for\nadditional routing between the source and target nodes.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "channelId",
        "description": ""
      },
      {
        "length": 60,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "buffer",
        "description": "TAO rules apply"
      },
      {
        "length": 60,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "buffer",
        "description": "TAO rules apply"
      }
    ],
    "statics": []
  },
  "341": {
    "description": "Abstract node status information.\nAll UAVCAN nodes are required to publish this message periodically.\nPublication period may vary within these limits.\nIt is NOT recommended to change it at run time.\nIf a node fails to publish this message in this amount of time, it should be considered offline.\nUptime counter should never overflow.\nOther nodes may detect that a remote node has restarted when this value goes backwards.\nAbstract node health.\nCurrent mode.\nMode OFFLINE can be actually reported by the node to explicitly inform other network\nparticipants that the sending node is about to shutdown. In this case other nodes will not\nhave to wait OFFLINE_TIMEOUT_MS before they detect that the node is no longer available.\nReserved values can be used in future revisions of the specification.\nNot used currently, keep zero when publishing, ignore when receiving.\nOptional, vendor-specific node status code, e.g. a fault code or a status bitmask.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "uptimeSec",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 2,
        "name": "health",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 3,
        "name": "mode",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 3,
        "name": "subMode",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 16,
        "name": "vendorSpecificStatusCode",
        "description": ""
      }
    ],
    "statics": [
      "uint16 MAX_BROADCASTING_PERIOD_MS = 1000",
      "uint16 MIN_BROADCASTING_PERIOD_MS = 2",
      "uint16 OFFLINE_TIMEOUT_MS = 3000",
      "uint2 HEALTH_OK         = 0     # The node is functioning properly.",
      "uint2 HEALTH_WARNING    = 1     # A critical parameter went out of range or the node encountered a minor failure.",
      "uint2 HEALTH_ERROR      = 2     # The node encountered a major failure.",
      "uint2 HEALTH_CRITICAL   = 3     # The node suffered a fatal malfunction.",
      "uint3 MODE_OPERATIONAL      = 0         # Normal operating mode.",
      "uint3 MODE_INITIALIZATION   = 1         # Initialization is in progress; this mode is entered immediately after startup.",
      "uint3 MODE_MAINTENANCE      = 2         # E.g. calibration, the bootloader is running, etc.",
      "uint3 MODE_SOFTWARE_UPDATE  = 3         # New software/firmware is being loaded.",
      "uint3 MODE_OFFLINE          = 7         # The node is no longer available."
    ]
  },
  "380": {
    "description": "This message will be broadcasted when the node receives user input in the process of enumeration.\nThis field is unused; keep it empty\nName of the enumerated parameter.\nThis field must always be populated by the enumeratee.\nIf multiple parameters were enumerated at once (e.g. ESC index and the direction of rotation),\nthe field should contain the name of the most important parameter.",
    "variables": [
      {
        "length": 92,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "parameterName",
        "description": ""
      }
    ],
    "statics": []
  },
  "390": {
    "description": "THIS DEFINITION IS SUBJECT TO CHANGE.\nThis message is used by allocation servers to find each other's node ID.\nPlease refer to the specification for details.\nA server should stop publishing this message as soon as it has discovered all other nodes in the cluster.\nAn exception applies: when a server receives a Discovery message from another server where the list\nof known nodes is incomplete (i.e. len(known_nodes) < configured_cluster_size), the server must\npublish a discovery message once. This condition allows other servers to quickly re-discover the cluster\nafter restart.\nThis message should be broadcasted by the server at this interval until all other servers are discovered.\nNumber of servers in the cluster as configured on the sender.\nNode ID of servers that are known to the publishing server, including the publishing server itself.\nCapacity of this array defines maximum size of the server cluster.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "configuredClusterSize",
        "description": ""
      },
      {
        "length": 5,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "knownNodes",
        "description": ""
      }
    ],
    "statics": [
      "uint16 BROADCASTING_PERIOD_MS = 1000"
    ]
  },
  "1000": {
    "description": "Inertial data and orientation in body frame.\nNormalized quaternion\nrad/sec\nm/s^2",
    "variables": [
      {
        "length": 4,
        "kind": "floatArray",
        "bits": 16,
        "name": "orientationXyzw",
        "description": ""
      },
      {
        "length": 9,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "orientationCovariance",
        "description": ""
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 16,
        "name": "angularVelocity",
        "description": ""
      },
      {
        "length": 9,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "angularVelocityCovariance",
        "description": ""
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 16,
        "name": "linearAcceleration",
        "description": ""
      },
      {
        "length": 9,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "linearAccelerationCovariance",
        "description": ""
      }
    ],
    "statics": []
  },
  "1001": {
    "description": "Magnetic field readings, in Gauss, in body frame.\nSI units are avoided because of float16 range limitations.\nThis message is deprecated. Use the newer 1002.MagneticFieldStrength2.uavcan message.",
    "variables": [
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 16,
        "name": "magneticFieldGa",
        "description": ""
      },
      {
        "length": 9,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "magneticFieldCovariance",
        "description": ""
      }
    ],
    "statics": []
  },
  "1002": {
    "description": "Magnetic field readings, in Gauss, in body frame.\nSI units are avoided because of float16 range limitations.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "sensorId",
        "description": ""
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 16,
        "name": "magneticFieldGa",
        "description": ""
      },
      {
        "length": 9,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "magneticFieldCovariance",
        "description": ""
      }
    ],
    "statics": []
  },
  "1003": {
    "description": "Raw IMU data with timestamps.\nTHIS DEFINITION MAY BE CHANGED IN A NON-BACKWARD-COMPATIBLE WAY IN THE FUTURE.\nData acquisition timestamp in the bus shared time base.\nIntegration interval, seconds.\nSet to a non-positive value if the integrated samples are not available\n(in this case, only the latest point samples will be valid).\nAngular velocity samples in radian/second.\nThe samples are represented in the body frame, the axes are ordered as follows:\n  1. angular velocity around X (roll rate)\n  2. angular velocity around Y (pitch rate)\n  3. angular velocity around Z (yaw rate)\nLinear acceleration samples in meter/(second^2).\nThe samples are represented in the body frame, the axes are ordered as follows:\n  1. linear acceleration along X (forward positive)\n  2. linear acceleration along Y (right positive)\n  3. linear acceleration along Z (down positive)\nCovariance matrix. The diagonal entries are ordered as follows:\n  1. roll rate                (radian^2)/(second^2)\n  2. pitch rate               (radian^2)/(second^2)\n  3. yaw rate                 (radian^2)/(second^2)\n  4. forward acceleration     (meter^2)/(second^4)\n  5. rightward acceleration   (meter^2)/(second^4)\n  6. downward acceleration    (meter^2)/(second^4)",
    "variables": [
      {
        "kind": "float",
        "bits": 32,
        "name": "integrationInterval",
        "description": ""
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 16,
        "name": "rateGyroLatest",
        "description": "Latest sample, radian/second"
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 32,
        "name": "rateGyroIntegral",
        "description": "Integrated samples, radian/second"
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 16,
        "name": "accelerometerLatest",
        "description": "Latest sample, meter/(second^2)"
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 32,
        "name": "accelerometerIntegral",
        "description": "Integrated samples, meter/(second^2)"
      },
      {
        "length": 36,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "covariance",
        "description": ""
      }
    ],
    "statics": []
  },
  "1010": {
    "description": "Actuator commands.\nThe system supports up to 256 actuators; up to 15 of them can be commanded with one message.",
    "variables": [],
    "statics": []
  },
  "1011": {
    "description": "Generic actuator feedback, if available.\nUnknown fields should be set to NAN.\nWhether the units are linear or angular depends on the actuator type (refer to the Command data type).",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "actuatorId",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "position",
        "description": "meter or radian"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "force",
        "description": "Newton or Newton metre"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "speed",
        "description": "meter per second or radian per second"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "powerRatingPct",
        "description": "0 - unloaded, 100 - full load"
      }
    ],
    "statics": [
      "uint7 POWER_RATING_PCT_UNKNOWN = 127"
    ]
  },
  "1020": {
    "description": "TAS.",
    "variables": [
      {
        "kind": "float",
        "bits": 16,
        "name": "trueAirspeed",
        "description": "m/s"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "trueAirspeedVariance",
        "description": "(m/s)^2"
      }
    ],
    "statics": []
  },
  "1021": {
    "description": "IAS.",
    "variables": [
      {
        "kind": "float",
        "bits": 16,
        "name": "indicatedAirspeed",
        "description": "m/s"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "indicatedAirspeedVariance",
        "description": "(m/s)^2"
      }
    ],
    "statics": []
  },
  "1025": {
    "description": "Angle of attack.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "sensorId",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "aoa",
        "description": "Radians"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "aoaVariance",
        "description": "Radians^2"
      }
    ],
    "statics": [
      "uint8 SENSOR_ID_LEFT = 254",
      "uint8 SENSOR_ID_RIGHT = 255"
    ]
  },
  "1026": {
    "description": "Body sideslip in radians.",
    "variables": [
      {
        "kind": "float",
        "bits": 16,
        "name": "sideslipAngle",
        "description": "Radians"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "sideslipAngleVariance",
        "description": "Radians^2"
      }
    ],
    "statics": []
  },
  "1027": {
    "description": "Raw Air Data.\nNote: unused vars should be assigned NaN\nHeater State\n\nPressure Data\nTemperature Data",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "flags",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "staticPressure",
        "description": "Pascal"
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "differentialPressure",
        "description": "Pascal"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "staticPressureSensorTemperature",
        "description": "Kelvin"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "differentialPressureSensorTemperature",
        "description": "Kelvin"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "staticAirTemperature",
        "description": "Kelvin"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "pitotTemperature",
        "description": "Kelvin"
      },
      {
        "length": 16,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "covariance",
        "description": "order of diagonal elements : "
      }
    ],
    "statics": [
      "uint8 FLAG_HEATER_AVAILABLE      = 1",
      "uint8 FLAG_HEATER_WORKING        = 2",
      "uint8 FLAG_HEATER_OVERCURRENT    = 4",
      "uint8 FLAG_HEATER_OPENCIRCUIT    = 8"
    ]
  },
  "1028": {
    "description": "Static pressure.",
    "variables": [
      {
        "kind": "float",
        "bits": 32,
        "name": "staticPressure",
        "description": "Pascal"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "staticPressureVariance",
        "description": "Pascal^2"
      }
    ],
    "statics": []
  },
  "1029": {
    "description": "Static temperature.",
    "variables": [
      {
        "kind": "float",
        "bits": 16,
        "name": "staticTemperature",
        "description": "Kelvin"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "staticTemperatureVariance",
        "description": "Kelvin^2"
      }
    ],
    "statics": []
  },
  "1030": {
    "description": "Raw ESC command normalized into [-8192, 8191]; negative values indicate reverse rotation.\nThe ESC should normalize the setpoint into its effective input range.\nNon-zero setpoint value below minimum should be interpreted as min valid setpoint for the given motor.",
    "variables": [
      {
        "length": 20,
        "range": true,
        "kind": "intArray",
        "bits": 14,
        "name": "cmd",
        "description": ""
      }
    ],
    "statics": []
  },
  "1031": {
    "description": "Simple RPM setpoint.\nThe ESC should automatically clamp the setpoint according to the minimum and maximum supported RPM;\nfor example, given a ESC that operates in the range 100 to 10000 RPM, a setpoint of 1 RPM will be clamped to 100 RPM.\nNegative values indicate reverse rotation.",
    "variables": [
      {
        "length": 20,
        "range": true,
        "kind": "intArray",
        "bits": 18,
        "name": "rpm",
        "description": ""
      }
    ],
    "statics": []
  },
  "1034": {
    "description": "Generic ESC status.\nUnknown fields should be set to NAN.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "errorCount",
        "description": "Resets when the motor restarts"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "voltage",
        "description": "Volt"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "current",
        "description": "Ampere. Can be negative in case of a regenerative braking."
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "temperature",
        "description": "Kelvin"
      },
      {
        "kind": "int",
        "bits": 18,
        "name": "rpm",
        "description": "Negative value indicates reverse rotation"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "powerRatingPct",
        "description": "Instant demand factor in percent (percent of maximum power); range 0% to 127%."
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 5,
        "name": "escIndex",
        "description": ""
      }
    ],
    "statics": []
  },
  "1040": {
    "description": "Generic camera gimbal control.\nThis message can only be used in the following modes:\n - COMMAND_MODE_ANGULAR_VELOCITY\n - COMMAND_MODE_ORIENTATION_FIXED_FRAME\n - COMMAND_MODE_ORIENTATION_BODY_FRAME\nTarget operation mode - how to handle this message.\nSee the list of acceptable modes above.\nIn the angular velocity mode, this field contains a rate quaternion.\nIn the orientation mode, this field contains orientation either in fixed frame or in body frame.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "gimbalId",
        "description": ""
      },
      {
        "length": 4,
        "kind": "floatArray",
        "bits": 16,
        "name": "quaternionXyzw",
        "description": ""
      }
    ],
    "statics": []
  },
  "1041": {
    "description": "Generic camera gimbal control.\nThis message can only be used in the following modes:\n - COMMAND_MODE_GEO_POI\nTarget operation mode - how to handle this message.\nSee the list of acceptable modes above.\nCoordinates of the POI (point of interest).",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "gimbalId",
        "description": ""
      },
      {
        "kind": "int",
        "bits": 32,
        "name": "longitudeDeg1E7",
        "description": "1 LSB = 1e-7 deg"
      },
      {
        "kind": "int",
        "bits": 32,
        "name": "latitudeDeg1E7",
        "description": ""
      },
      {
        "kind": "int",
        "bits": 22,
        "name": "heightCm",
        "description": "1 LSB = 10 mm"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 2,
        "name": "heightReference",
        "description": ""
      }
    ],
    "statics": [
      "uint2 HEIGHT_REFERENCE_ELLIPSOID = 0",
      "uint2 HEIGHT_REFERENCE_MEAN_SEA_LEVEL = 1"
    ]
  },
  "1044": {
    "description": "Generic gimbal status.\nCamera axis orientation in body frame (not in fixed frame).\nPlease refer to the UAVCAN coordinate frame conventions.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "gimbalId",
        "description": ""
      },
      {
        "length": 4,
        "kind": "floatArray",
        "bits": 16,
        "name": "cameraOrientationInBodyFrameXyzw",
        "description": ""
      },
      {
        "length": 9,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "cameraOrientationInBodyFrameCovariance",
        "description": "+inf for non-existent axes"
      }
    ],
    "statics": []
  },
  "1050": {
    "description": "Generic narrow-beam range sensor data.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "sensorId",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "fieldOfView",
        "description": "Radians"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 5,
        "name": "sensorType",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 3,
        "name": "readingType",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "range",
        "description": "Meters"
      }
    ],
    "statics": [
      "uint5 SENSOR_TYPE_UNDEFINED = 0",
      "uint5 SENSOR_TYPE_SONAR     = 1",
      "uint5 SENSOR_TYPE_LIDAR     = 2",
      "uint5 SENSOR_TYPE_RADAR     = 3",
      "uint3 READING_TYPE_UNDEFINED   = 0   # Range is unknown",
      "uint3 READING_TYPE_VALID_RANGE = 1   # Range field contains valid distance",
      "uint3 READING_TYPE_TOO_CLOSE   = 2   # Range field contains min range for the sensor",
      "uint3 READING_TYPE_TOO_FAR     = 3   # Range field contains max range for the sensor"
    ]
  },
  "1060": {
    "description": "GNSS navigation solution with uncertainty.\nThis message is deprecated. Use the newer 1063.Fix2.uavcan message.\nTime solution.\nTime standard (GPS, UTC, TAI, etc) is defined in the field below.\nTime standard used in the GNSS timestamp field.\nIf known, the number of leap seconds allows to perform conversions between some time standards.\nPosition and velocity solution\nFix status\nPrecision",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 3,
        "name": "gnssTimeStandard",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "numLeapSeconds",
        "description": ""
      },
      {
        "kind": "int",
        "bits": 37,
        "name": "longitudeDeg1E8",
        "description": "Longitude degrees multiplied by 1e8 (approx. 1 mm per LSB)"
      },
      {
        "kind": "int",
        "bits": 37,
        "name": "latitudeDeg1E8",
        "description": "Latitude degrees multiplied by 1e8 (approx. 1 mm per LSB on equator)"
      },
      {
        "kind": "int",
        "bits": 27,
        "name": "heightEllipsoidMm",
        "description": "Height above ellipsoid in millimeters"
      },
      {
        "kind": "int",
        "bits": 27,
        "name": "heightMslMm",
        "description": "Height above mean sea level in millimeters"
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 16,
        "name": "nedVelocity",
        "description": "NED frame (north-east-down) in meters per second"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 6,
        "name": "satsUsed",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 2,
        "name": "status2DFix",
        "description": "= 2"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 2,
        "name": "status3DFix",
        "description": "= 3"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 2,
        "name": "status",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "pdop",
        "description": ""
      },
      {
        "length": 9,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "positionCovariance",
        "description": "m^2"
      },
      {
        "length": 9,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "velocityCovariance",
        "description": "(m/s)^2"
      }
    ],
    "statics": [
      "uint3 GNSS_TIME_STANDARD_NONE = 0  # Time is unknown",
      "uint3 GNSS_TIME_STANDARD_TAI  = 1",
      "uint3 GNSS_TIME_STANDARD_UTC  = 2",
      "uint3 GNSS_TIME_STANDARD_GPS  = 3",
      "uint8 NUM_LEAP_SECONDS_UNKNOWN = 0",
      "uint2 STATUS_NO_FIX    = 0",
      "uint2 STATUS_TIME_ONLY = 1"
    ]
  },
  "1061": {
    "description": "GNSS low priority auxiliary info.\nUnknown DOP parameters should be set to NAN.",
    "variables": [
      {
        "kind": "float",
        "bits": 16,
        "name": "gdop",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "pdop",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "hdop",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "vdop",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "tdop",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "ndop",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "edop",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "satsVisible",
        "description": "All visible sats of all available GNSS (e.g. GPS, GLONASS, etc)"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 6,
        "name": "satsUsed",
        "description": "All used sats of all available GNSS"
      }
    ],
    "statics": []
  },
  "1062": {
    "description": "GNSS RTCM SC-104 protocol raw stream container.\nRTCM messages that are longer than max data size can be split over multiple consecutive messages.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "protocolIdRtcm2",
        "description": "= 2"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "protocolIdRtcm3",
        "description": "= 3"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "protocolId",
        "description": ""
      },
      {
        "length": 128,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "data",
        "description": ""
      }
    ],
    "statics": [
      "uint8 PROTOCOL_ID_UNKNOWN = 0"
    ]
  },
  "1063": {
    "description": "GNSS ECEF and LLA navigation solution with uncertainty.\nGlobal network-synchronized time, if available, otherwise zero.\nTime solution.\nThe method and number of leap seconds which were in use for deriving the timestamp are\ndefined in the fields below.\nMethod used for deriving the GNSS timestamp field.\nThis data type relies on the following definitions:\n  Leap seconds  - Accumulated one-second adjustments applied to UTC since 1972.\n                  For reference, on May 2017, the number of leap seconds was equal 27.\n                  The number of leap seconds is taken from the field num_leap_seconds.\n                  Refer to https://en.wikipedia.org/wiki/Leap_second for a general overview.\n  TAI timestamp - The number of microseconds between the current TAI time and\n                  the TAI time at UTC 1970-01-01T00:00:00.\n  UTC timestamp - The number of microseconds between the current UTC time and\n                  UTC 1970-01-01T00:00:00.\n                  UTC can be expressed via TAI as follows (in seconds):\n                      UTC = TAI - num_leap_seconds - 10\n                  And via GPS (in seconds):\n                      UTC = GPS - num_leap_seconds + 9\n  GPS timestamp - The number of microseconds between the current GPS time and\n                  the GPS time at UTC 1970-01-01T00:00:00.\n                  GPS time can be expressed via TAI as follows (in seconds):\n                      GPS = TAI - 19\nAccumulated one-second adjustments applied to UTC since 1972.\nThe number must agree with the currently correct number of UTC leap seconds. If this cannot\nbe garanteed, the field must be set to NUM_LEAP_SECONDS_UNKNOWN.\nPosition and velocity solution\nFix status\nGNSS Mode\nGNSS Sub mode\nPrecision\nPosition and velocity solution in ECEF, if available",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 3,
        "name": "gnssTimeStandard",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "numLeapSeconds",
        "description": ""
      },
      {
        "kind": "int",
        "bits": 37,
        "name": "longitudeDeg1E8",
        "description": "Longitude degrees multiplied by 1e8 (approx. 1 mm per LSB)"
      },
      {
        "kind": "int",
        "bits": 37,
        "name": "latitudeDeg1E8",
        "description": "Latitude degrees multiplied by 1e8 (approx. 1 mm per LSB on equator)"
      },
      {
        "kind": "int",
        "bits": 27,
        "name": "heightEllipsoidMm",
        "description": "Height above ellipsoid in millimeters"
      },
      {
        "kind": "int",
        "bits": 27,
        "name": "heightMslMm",
        "description": "Height above mean sea level in millimeters"
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 32,
        "name": "nedVelocity",
        "description": "NED frame (north-east-down) in meters per second"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 6,
        "name": "satsUsed",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 2,
        "name": "status2DFix",
        "description": "= 2"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 2,
        "name": "status3DFix",
        "description": "= 3"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 2,
        "name": "status",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 4,
        "name": "mode",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 6,
        "name": "subMode",
        "description": ""
      },
      {
        "length": 36,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "covariance",
        "description": "Position and velocity covariance. Units are"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "pdop",
        "description": ""
      }
    ],
    "statics": [
      "uint3 GNSS_TIME_STANDARD_NONE = 0  # Time is unknown",
      "uint3 GNSS_TIME_STANDARD_TAI  = 1",
      "uint3 GNSS_TIME_STANDARD_UTC  = 2",
      "uint3 GNSS_TIME_STANDARD_GPS  = 3",
      "uint8 NUM_LEAP_SECONDS_UNKNOWN = 0",
      "uint2 STATUS_NO_FIX    = 0",
      "uint2 STATUS_TIME_ONLY = 1",
      "uint4 MODE_SINGLE      = 0",
      "uint4 MODE_DGPS        = 1",
      "uint4 MODE_RTK         = 2",
      "uint4 MODE_PPP         = 3",
      "uint6 SUB_MODE_DGPS_OTHER    = 0",
      "uint6 SUB_MODE_DGPS_SBAS     = 1",
      "uint6 SUB_MODE_RTK_FLOAT     = 0",
      "uint6 SUB_MODE_RTK_FIXED     = 1"
    ]
  },
  "1070": {
    "description": "Generic cargo holder/hardpoint command.\nEither a binary command (0 - release, 1+ - hold) or bitmask",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "hardpointId",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 16,
        "name": "command",
        "description": ""
      }
    ],
    "statics": []
  },
  "1071": {
    "description": "Generic cargo holder/hardpoint status.\nMeaning is the same as for the command field in the Command message",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "hardpointId",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "payloadWeight",
        "description": "Newton"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "payloadWeightVariance",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 16,
        "name": "status",
        "description": ""
      }
    ],
    "statics": []
  },
  "1080": {
    "description": "Nodes that are capable of producing sounds should obey.",
    "variables": [
      {
        "kind": "float",
        "bits": 16,
        "name": "frequency",
        "description": "Hz"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "duration",
        "description": "Sec"
      }
    ],
    "statics": []
  },
  "1081": {
    "description": "Lights control command.",
    "variables": [],
    "statics": []
  },
  "1090": {
    "description": "Primary power supply status.\nTypical publishing rate should be around 1~2 Hz.\nHow many hours left to full discharge at average load over the last 10 seconds.\nTrue if the publishing node senses that an external power source can be used, e.g. to charge batteries.\nRemaining energy estimate in percent.",
    "variables": [
      {
        "kind": "float",
        "bits": 16,
        "name": "hoursToEmptyAt10SecAvgPower",
        "description": "[Hours]"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "hoursToEmptyAt10SecAvgPowerVariance",
        "description": "[Hours^2]"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "remainingEnergyPct",
        "description": "[Percent] Required"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "remainingEnergyPctStdev",
        "description": "[Percent] Error standard deviation. Use best guess if unknown."
      }
    ],
    "statics": []
  },
  "1091": {
    "description": "Generic electrical circuit info.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 16,
        "name": "circuitId",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "voltage",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "current",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "errorFlags",
        "description": ""
      }
    ],
    "statics": [
      "uint8 ERROR_FLAG_OVERVOLTAGE  = 1",
      "uint8 ERROR_FLAG_UNDERVOLTAGE = 2",
      "uint8 ERROR_FLAG_OVERCURRENT  = 4",
      "uint8 ERROR_FLAG_UNDERCURRENT = 8"
    ]
  },
  "1092": {
    "description": "Single battery info.\nTypical publishing rate should be around 0.2~1 Hz.\nPlease refer to the Smart Battery data specification for some elaboration.\nPrimary parameters.\nSome fields can be set to NAN if their values are unknown.\nFull charge capacity is expected to slowly reduce as the battery is aging. Normally its estimate is updated after\nevery charging cycle.\nStatus flags.\nNotes:\n - CHARGING must be always set as long as the battery is connected to a charger, even if the charging is complete.\n - CHARGED must be cleared immediately when the charger is disconnected.\nState of Health (SOH) estimate, in percent.\nhttp://en.wikipedia.org/wiki/State_of_health\nRelative State of Charge (SOC) estimate, in percent.\nhttp://en.wikipedia.org/wiki/State_of_charge\nBattery identification.\nModel instance ID must be unique within the same battery model name.\nModel name is a human-readable string that normally should include the vendor name, model name, and chemistry\ntype of this battery. This field should be assumed case-insensitive. Example: \"Zubax Smart Battery v1.1 LiPo\".",
    "variables": [
      {
        "kind": "float",
        "bits": 16,
        "name": "temperature",
        "description": "[Kelvin]"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "voltage",
        "description": "[Volt]"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "current",
        "description": "[Ampere]"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "averagePower10Sec",
        "description": "[Watt] Average power consumption over the last 10 seconds"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "remainingCapacityWh",
        "description": "[Watt hours] Will be increasing during charging"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "fullChargeCapacityWh",
        "description": "[Watt hours] Predicted battery capacity when it is fully charged. Falls with aging"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "hoursToFullCharge",
        "description": "[Hours] Charging is expected to complete in this time; zero if not charging"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 11,
        "name": "statusFlags",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "stateOfHealthPct",
        "description": "Health of the battery, in percent, optional"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "stateOfChargePct",
        "description": "Percent of the full charge [0, 100]. This field is required"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "stateOfChargePctStdev",
        "description": "SOC error standard deviation; use best guess if unknown"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "batteryId",
        "description": "Identifies the battery within this vehicle, e.g. 0 - primary battery"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "modelInstanceId",
        "description": "Set to zero if not applicable"
      },
      {
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "modelName",
        "description": "Battery model name"
      }
    ],
    "statics": [
      "uint11 STATUS_FLAG_IN_USE       = 1     # The battery is currently used as a power supply",
      "uint11 STATUS_FLAG_CHARGING     = 2     # Charger is active",
      "uint11 STATUS_FLAG_CHARGED      = 4     # Charging complete, but the charger is still active",
      "uint11 STATUS_FLAG_TEMP_HOT     = 8     # Battery temperature is above normal",
      "uint11 STATUS_FLAG_TEMP_COLD    = 16    # Battery temperature is below normal",
      "uint11 STATUS_FLAG_OVERLOAD     = 32    # Safe operating area violation",
      "uint11 STATUS_FLAG_BAD_BATTERY  = 64    # This battery should not be used anymore (e.g. low SOH)",
      "uint11 STATUS_FLAG_NEED_SERVICE = 128   # This battery requires maintenance (e.g. balancing, full recharge)",
      "uint11 STATUS_FLAG_BMS_ERROR    = 256   # Battery management system/controller error, smart battery interface error",
      "uint11 STATUS_FLAG_RESERVED_A   = 512   # Keep zero",
      "uint11 STATUS_FLAG_RESERVED_B   = 1024  # Keep zero",
      "uint7 STATE_OF_HEALTH_UNKNOWN = 127     # Use this constant if SOH cannot be estimated"
    ]
  },
  "1100": {
    "description": "This message represents the system arming status.\nSome nodes may refuse to operate unless the system is fully armed.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "status",
        "description": ""
      }
    ],
    "statics": [
      "uint8 STATUS_DISARMED           = 0",
      "uint8 STATUS_FULLY_ARMED        = 255"
    ]
  },
  "1110": {
    "description": "Generic device temperature",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 16,
        "name": "deviceId",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "temperature",
        "description": "in kelvin"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "errorFlags",
        "description": ""
      }
    ],
    "statics": [
      "uint8 ERROR_FLAG_OVERHEATING = 1",
      "uint8 ERROR_FLAG_OVERCOOLING = 2"
    ]
  },
  "1120": {
    "description": "Generic status message of a piston engine control system.\nAll integer fields are required unless stated otherwise.\nAll floating point fields are optional unless stated otherwise; unknown/unapplicable fields should be set to NaN.\nAbstract engine state. The flags defined below can provide further elaboration.\nThis is a required field.\nThe engine is not running. This is the default state.\nNext states: STARTING, FAULT\nThe engine is starting. This is a transient state.\nNext states: STOPPED, RUNNING, FAULT\nThe engine is running normally.\nSome error flags may be set to indicate non-fatal issues, e.g. overheating.\nNext states: STOPPED, FAULT\nThe engine can no longer function.\nThe error flags may contain additional information about the nature of the fault.\nNext states: STOPPED.\nGeneral status flags.\nNote that not all flags are required. Those that aren't are prepended with a validity flag, which is, obviously,\nalways required; when the validity flag is set, it is assumed that the relevant flags are set correctly.\nIf the validity flag is cleared, then the state of the relevant flags should be ignored.\nAll unused bits must be cleared.\nGeneral error. This flag is required, and it can be used to indicate an error condition\nthat does not fit any of the other flags.\nNote that the vendor may also report additional status information via the vendor specific status code\nfield of the NodeStatus message.\nError of the crankshaft sensor. This flag is optional.\nTemperature levels. These flags are optional; either none of them or all of them are supported.\nFuel pressure. These flags are optional; either none of them or all of them are supported.\nDetonation warning. This flag is optional.\nThis warning is cleared immediately after broadcasting is done if detonation is no longer happening.\nMisfire warning. This flag is optional.\nThis warning is cleared immediately after broadcasting is done if misfire is no longer happening.\nOil pressure. These flags are optional; either none of them or all of them are supported.\nDebris warning. This flag is optional.\nReserved space\nEngine load estimate.\nUnit: percent.\nRange: [0, 127].\nEngine speed.\nUnit: revolutions per minute.\nSpark dwell time.\nUnit: millisecond.\nAtmospheric (barometric) pressure.\nUnit: kilopascal.\nEngine intake manifold pressure.\nUnit: kilopascal.\nEngine intake manifold temperature.\nUnit: kelvin.\nEngine coolant temperature.\nUnit: kelvin.\nOil pressure.\nUnit: kilopascal.\nOil temperature.\nUnit: kelvin.\nFuel pressure.\nUnit: kilopascal.\nInstant fuel consumption estimate.\nThe estimated value should be low-pass filtered in order to prevent aliasing effects.\nUnit: (centimeter^3)/minute.\nEstimate of the consumed fuel since the start of the engine.\nThis variable MUST be reset when the engine is stopped.\nUnit: centimeter^3.\nThrottle position.\nUnit: percent.\nThe index of the publishing ECU.\nSpark plug activity report.\nCan be used during pre-flight tests of the spark subsystem.\nPer-cylinder status information.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 2,
        "name": "state",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 30,
        "name": "flags",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "engineLoadPercent",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 17,
        "name": "engineSpeedRpm",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "sparkDwellTimeMs",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "atmosphericPressureKpa",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "intakeManifoldPressureKpa",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "intakeManifoldTemperature",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "coolantTemperature",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "oilPressure",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "oilTemperature",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "fuelPressure",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "fuelConsumptionRateCm3Pm",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "estimatedConsumedFuelVolumeCm3",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "throttlePositionPercent",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 6,
        "name": "ecuIndex",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 3,
        "name": "sparkPlugUsage",
        "description": ""
      }
    ],
    "statics": [
      "uint2 STATE_STOPPED = 0",
      "uint2 STATE_STARTING = 1",
      "uint2 STATE_RUNNING = 2",
      "uint2 STATE_FAULT = 3",
      "uint30 FLAG_GENERAL_ERROR                       = 1",
      "uint30 FLAG_CRANKSHAFT_SENSOR_ERROR_SUPPORTED   = 2",
      "uint30 FLAG_CRANKSHAFT_SENSOR_ERROR             = 4",
      "uint30 FLAG_TEMPERATURE_SUPPORTED               = 8",
      "uint30 FLAG_TEMPERATURE_BELOW_NOMINAL           = 16      # Under-temperature warning",
      "uint30 FLAG_TEMPERATURE_ABOVE_NOMINAL           = 32      # Over-temperature warning",
      "uint30 FLAG_TEMPERATURE_OVERHEATING             = 64      # Critical overheating",
      "uint30 FLAG_TEMPERATURE_EGT_ABOVE_NOMINAL       = 128     # Exhaust gas over-temperature warning",
      "uint30 FLAG_FUEL_PRESSURE_SUPPORTED             = 256",
      "uint30 FLAG_FUEL_PRESSURE_BELOW_NOMINAL         = 512     # Under-pressure warning",
      "uint30 FLAG_FUEL_PRESSURE_ABOVE_NOMINAL         = 1024    # Over-pressure warning",
      "uint30 FLAG_DETONATION_SUPPORTED                = 2048",
      "uint30 FLAG_DETONATION_OBSERVED                 = 4096    # Detonation condition observed warning",
      "uint30 FLAG_MISFIRE_SUPPORTED                   = 8192",
      "uint30 FLAG_MISFIRE_OBSERVED                    = 16384   # Misfire condition observed warning",
      "uint30 FLAG_OIL_PRESSURE_SUPPORTED              = 32768",
      "uint30 FLAG_OIL_PRESSURE_BELOW_NOMINAL          = 65536   # Under-pressure warning",
      "uint30 FLAG_OIL_PRESSURE_ABOVE_NOMINAL          = 131072  # Over-pressure warning",
      "uint30 FLAG_DEBRIS_SUPPORTED                    = 262144",
      "uint30 FLAG_DEBRIS_DETECTED                     = 524288  # Detection of debris warning",
      "uint3 SPARK_PLUG_SINGLE         = 0",
      "uint3 SPARK_PLUG_FIRST_ACTIVE   = 1",
      "uint3 SPARK_PLUG_SECOND_ACTIVE  = 2",
      "uint3 SPARK_PLUG_BOTH_ACTIVE    = 3"
    ]
  },
  "1129": {
    "description": "Generic fuel tank status message.\nAll fields are required unless stated otherwise. Unpopulated optional fields should be set to NaN.\nReserved for future use.\nThe estimated amount of fuel.\nThe reported values can be either measured directly using appropriate sensors,\nor they can be estimated by fusing the data provided by various sensors.\nFor example, a Kalman filter can be used to fuse the data from fuel level sensors and flow sensors.\nAll fields are required.\nEstimate of the current fuel consumption rate.\nThe flow can be negative if the fuel is being transferred between the tanks or during refueling.\nThis field is required.\nUnit: (centimeter^3)/minute\nFuel temperature.\nThis field is optional, set to NaN if not provided.\nUnit: kelvin\nThe ID of the current fuel tank.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "availableFuelVolumePercent",
        "description": "Unit: percent, from 0% to 100%"
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "availableFuelVolumeCm3",
        "description": "Unit: centimeter^3"
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "fuelConsumptionRateCm3Pm",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "fuelTemperature",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "fuelTankId",
        "description": ""
      }
    ],
    "statics": []
  },
  "2000": {
    "description": "Inertial data and orientation in body frame with fused location.\nFields marked as optional should be set to NaN if the corresponding value is unknown.\nGlobal network synchronized timestamp, if known.\nSet to zero if the timestamp is not known.\nGeo location [angular degree].\nHeight estimates [meter].\nAtmospheric pressure adjusted to sea level [hectopascal].\nRotation quaternion between the NED frame and the body frame.\nZero rotation corresponds to the following orientation:\n  X facing north\n  Y facing east\n  Z facing down\nColumn order:\n  longitude                                   [meter^2]\n  latitude                                    [meter^2]\n  height (MSL or ellipsoid, whichever worse)  [meter^2]\n  roll angle                                  [radian^2]\n  pitch angle                                 [radian^2]\n  yaw angle                                   [radian^2]\nLinear velocity in the body frame, X-Y-Z [meter/second].\nAngular velocity in the body frame, roll-pitch-yaw [radian/second].\nLow resolution estimate of the linear acceleration in the body frame [(meter/second)^2].\nThis estimate should be properly downsampled in order to avoid aliasing effects.\nColumn order:\n  X velocity      [(meter/second)^2]\n  Y velocity      [(meter/second)^2]\n  Z velocity      [(meter/second)^2]\n  roll velocity   [(radian/second)^2]\n  pitch velocity  [(radian/second)^2]\n  yaw velocity    [(radian/second)^2]",
    "variables": [
      {
        "kind": "float",
        "bits": 64,
        "name": "longitude",
        "description": "required"
      },
      {
        "kind": "float",
        "bits": 64,
        "name": "latitude",
        "description": "required"
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "heightEllipsoid",
        "description": "Above ellipsoid (required)"
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "heightMsl",
        "description": "Above the mean sea level (required)"
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "heightAgl",
        "description": "Above ground level (provided by radar altimeter or LIDAR) (optional)"
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "heightBaro",
        "description": "Barometric height (optional)"
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "qnhHpa",
        "description": "optional"
      },
      {
        "length": 4,
        "kind": "floatArray",
        "bits": 32,
        "name": "orientationXyzw",
        "description": ""
      },
      {
        "length": 36,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "poseCovariance",
        "description": ""
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 32,
        "name": "linearVelocityBody",
        "description": ""
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 32,
        "name": "angularVelocityBody",
        "description": ""
      },
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 16,
        "name": "linearAccelerationBody",
        "description": ""
      },
      {
        "length": 36,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "velocityCovariance",
        "description": ""
      }
    ],
    "statics": []
  },
  "2010": {
    "description": "This message struct carries arbitrary data in the format of the specified high-level protocol.\nThe data will be delivered to all nodes that are interested in tunneled protocols.\nFiner addressing schemes may be implemented using the means provided by the encapsulated protocol.\nThe channelID allows for additional routing between the source and target nodes.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "channelId",
        "description": ""
      },
      {
        "length": 60,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "buffer",
        "description": "TAO rules apply"
      }
    ],
    "statics": []
  },
  "16370": {
    "description": "Generic named parameter (key/value pair).\nIntegers are exactly representable in the range (-2^24, 2^24) which is (-16'777'216, 16'777'216).\nTail array optimization is enabled, so if key length does not exceed 3 characters, the whole\nmessage can fit into one CAN frame. The message always fits into one CAN FD frame.",
    "variables": [
      {
        "kind": "float",
        "bits": 32,
        "name": "value",
        "description": ""
      },
      {
        "length": 58,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "key",
        "description": ""
      }
    ],
    "statics": []
  },
  "16383": {
    "description": "Generic log message.\nAll items are byte aligned.",
    "variables": [
      {
        "length": 31,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "source",
        "description": ""
      },
      {
        "length": 90,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "text",
        "description": ""
      }
    ],
    "statics": []
  },
  "CoarseOrientation.uavcan": {
    "definition": "#\n# Nested type.\n# Coarse, low-resolution 3D orientation represented as fixed axes in 16 bit.\n#\n# Roll, pitch, yaw angles in radians should be multiplied by\n# ANGLE_MULTIPLIER in order to convert them to the coarse representation.\n#\n# ANGLE_MULTIPLIER = NORM / PI\n#\n# Where NORM is 12, because it:\n#  - Fits the maximum range of a signed 5 bit integer\n#  - Allows to exactly represent the following angles:\n#    0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, and negatives\n#\n\nfloat32 ANGLE_MULTIPLIER = 4.7746482927568605\n\nint5[3] fixed_axis_roll_pitch_yaw\n\nbool orientation_defined    # False if the orientation is actually not defined\n"
  },
  "CoarseOrientation": {
    "description": "Nested type.\nCoarse, low-resolution 3D orientation represented as fixed axes in 16 bit.\nRoll, pitch, yaw angles in radians should be multiplied by\nANGLE_MULTIPLIER in order to convert them to the coarse representation.\nANGLE_MULTIPLIER = NORM / PI\nWhere NORM is 12, because it:\n - Fits the maximum range of a signed 5 bit integer\n - Allows to exactly represent the following angles:\n   0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, and negatives",
    "variables": [
      {
        "length": 3,
        "kind": "intArray",
        "bits": 5,
        "name": "fixedAxisRollPitchYaw",
        "description": ""
      }
    ],
    "statics": [
      "float32 ANGLE_MULTIPLIER = 4.7746482927568605"
    ]
  },
  "Timestamp.uavcan": {
    "definition": "#\n# Global timestamp in microseconds, 7 bytes.\n#\n# Use this data type for timestamp fields in messages, like follows:\n#   uavcan.Timestamp timestamp\n#\n\nuint56 UNKNOWN = 0\ntruncated uint56 usec     # Microseconds\n"
  },
  "Timestamp": {
    "description": "Global timestamp in microseconds, 7 bytes.\nUse this data type for timestamp fields in messages, like follows:\n  uavcan.Timestamp timestamp",
    "variables": [],
    "statics": [
      "uint56 UNKNOWN = 0"
    ]
  },
  "1010.ArrayCommand.uavcan": {
    "definition": "#\n# Actuator commands.\n# The system supports up to 256 actuators; up to 15 of them can be commanded with one message.\n#\n\nCommand[<=15] commands\n"
  },
  "1011.Status.uavcan": {
    "definition": "#\n# Generic actuator feedback, if available.\n# Unknown fields should be set to NAN.\n#\n\nuint8 actuator_id\n\n#\n# Whether the units are linear or angular depends on the actuator type (refer to the Command data type).\n#\nfloat16 position        # meter or radian\nfloat16 force           # Newton or Newton metre\nfloat16 speed           # meter per second or radian per second\n\nvoid1\nuint7 POWER_RATING_PCT_UNKNOWN = 127\nuint7 power_rating_pct                # 0 - unloaded, 100 - full load\n"
  },
  "Command.uavcan": {
    "definition": "#\n# Nested type.\n# Single actuator command.\n#\n\nuint8 actuator_id\n\n#\n# Whether the units are linear or angular depends on the actuator type.\n#\nuint8 COMMAND_TYPE_UNITLESS     = 0     # [-1, 1]\nuint8 COMMAND_TYPE_POSITION     = 1     # meter or radian\nuint8 COMMAND_TYPE_FORCE        = 2     # Newton or Newton metre\nuint8 COMMAND_TYPE_SPEED        = 3     # meter per second or radian per second\nuint8 command_type\n\n#\n# Value of the above type\n#\nfloat16 command_value\n"
  },
  "Command": {
    "description": "Nested type.\nSingle actuator command.\nWhether the units are linear or angular depends on the actuator type.\nValue of the above type",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "actuatorId",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "commandType",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "commandValue",
        "description": ""
      }
    ],
    "statics": [
      "uint8 COMMAND_TYPE_UNITLESS     = 0     # [-1, 1]",
      "uint8 COMMAND_TYPE_POSITION     = 1     # meter or radian",
      "uint8 COMMAND_TYPE_FORCE        = 2     # Newton or Newton metre",
      "uint8 COMMAND_TYPE_SPEED        = 3     # meter per second or radian per second"
    ]
  },
  "1000.Solution.uavcan": {
    "definition": "#\n# Inertial data and orientation in body frame.\n#\n\nuavcan.Timestamp timestamp\n\n#\n# Normalized quaternion\n#\nfloat16[4] orientation_xyzw\nvoid4\nfloat16[<=9] orientation_covariance\n\n#\n# rad/sec\n#\nfloat16[3] angular_velocity\nvoid4\nfloat16[<=9] angular_velocity_covariance\n\n#\n# m/s^2\n#\nfloat16[3] linear_acceleration\nfloat16[<=9] linear_acceleration_covariance\n"
  },
  "1001.MagneticFieldStrength.uavcan": {
    "definition": "#\n# Magnetic field readings, in Gauss, in body frame.\n# SI units are avoided because of float16 range limitations.\n# This message is deprecated. Use the newer 1002.MagneticFieldStrength2.uavcan message.\n#\n\nfloat16[3] magnetic_field_ga\nfloat16[<=9] magnetic_field_covariance\n"
  },
  "1002.MagneticFieldStrength2.uavcan": {
    "definition": "#\n# Magnetic field readings, in Gauss, in body frame.\n# SI units are avoided because of float16 range limitations.\n#\n\nuint8 sensor_id\n\nfloat16[3] magnetic_field_ga\nfloat16[<=9] magnetic_field_covariance\n"
  },
  "1003.RawIMU.uavcan": {
    "definition": "#\n# Raw IMU data with timestamps.\n#\n# THIS DEFINITION MAY BE CHANGED IN A NON-BACKWARD-COMPATIBLE WAY IN THE FUTURE.\n#\n\n#\n# Data acquisition timestamp in the bus shared time base.\n#\nuavcan.Timestamp timestamp\n\n#\n# Integration interval, seconds.\n# Set to a non-positive value if the integrated samples are not available\n# (in this case, only the latest point samples will be valid).\n#\nfloat32 integration_interval\n\n#\n# Angular velocity samples in radian/second.\n# The samples are represented in the body frame, the axes are ordered as follows:\n#   1. angular velocity around X (roll rate)\n#   2. angular velocity around Y (pitch rate)\n#   3. angular velocity around Z (yaw rate)\n#\nfloat16[3] rate_gyro_latest                 # Latest sample, radian/second\nfloat32[3] rate_gyro_integral               # Integrated samples, radian/second\n\n#\n# Linear acceleration samples in meter/(second^2).\n# The samples are represented in the body frame, the axes are ordered as follows:\n#   1. linear acceleration along X (forward positive)\n#   2. linear acceleration along Y (right positive)\n#   3. linear acceleration along Z (down positive)\n#\nfloat16[3] accelerometer_latest             # Latest sample, meter/(second^2)\nfloat32[3] accelerometer_integral           # Integrated samples, meter/(second^2)\n\n#\n# Covariance matrix. The diagonal entries are ordered as follows:\n#   1. roll rate                (radian^2)/(second^2)\n#   2. pitch rate               (radian^2)/(second^2)\n#   3. yaw rate                 (radian^2)/(second^2)\n#   4. forward acceleration     (meter^2)/(second^4)\n#   5. rightward acceleration   (meter^2)/(second^4)\n#   6. downward acceleration    (meter^2)/(second^4)\n#\nfloat16[<=36] covariance\n"
  },
  "1020.TrueAirspeed.uavcan": {
    "definition": "#\n# TAS.\n#\n\nfloat16 true_airspeed           # m/s\nfloat16 true_airspeed_variance  # (m/s)^2\n"
  },
  "1021.IndicatedAirspeed.uavcan": {
    "definition": "#\n# IAS.\n#\n\nfloat16 indicated_airspeed              # m/s\nfloat16 indicated_airspeed_variance     # (m/s)^2\n"
  },
  "1025.AngleOfAttack.uavcan": {
    "definition": "#\n# Angle of attack.\n#\n\nuint8 SENSOR_ID_LEFT = 254\nuint8 SENSOR_ID_RIGHT = 255\nuint8 sensor_id\n\nfloat16 aoa             # Radians\nfloat16 aoa_variance    # Radians^2\n"
  },
  "1026.Sideslip.uavcan": {
    "definition": "#\n# Body sideslip in radians.\n#\n\nfloat16 sideslip_angle          # Radians\nfloat16 sideslip_angle_variance # Radians^2\n"
  },
  "1027.RawAirData.uavcan": {
    "definition": "#\n# Raw Air Data.\n#\n\n# Note: unused vars should be assigned NaN\n\n#\n# Heater State\n# \nuint8 FLAG_HEATER_AVAILABLE      = 1\nuint8 FLAG_HEATER_WORKING        = 2\nuint8 FLAG_HEATER_OVERCURRENT    = 4\nuint8 FLAG_HEATER_OPENCIRCUIT    = 8\nuint8 flags\n\n#\n# Pressure Data\n#\nfloat32 static_pressure                 # Pascal\nfloat32 differential_pressure           # Pascal\n\n#\n# Temperature Data\n#\nfloat16 static_pressure_sensor_temperature          # Kelvin\nfloat16 differential_pressure_sensor_temperature    # Kelvin\n\nfloat16 static_air_temperature          # Kelvin\n                                        # This field contains the raw temperature reading \n                                        # from the externally mounted temperature sensor or, \n                                        # in absence of one, the raw temperature of the pressure sensor.\n\nfloat16 pitot_temperature               # Kelvin\n\n\nfloat16[<=16] covariance                # order of diagonal elements : \n                                        # static_pressure, differential_pressure,\n                                        # static_air_temperature, pitot_temperature\n                                        # Pascal^2 for pressure variance and covariance\n                                        # Kevin^2 for Temperature variance and covariance\n                                        # Pascal*Kelvin for pressure/temperature covariance\n"
  },
  "1028.StaticPressure.uavcan": {
    "definition": "#\n# Static pressure.\n#\n\nfloat32 static_pressure                 # Pascal\nfloat16 static_pressure_variance        # Pascal^2\n"
  },
  "1029.StaticTemperature.uavcan": {
    "definition": "#\n# Static temperature.\n#\n\nfloat16 static_temperature              # Kelvin\nfloat16 static_temperature_variance     # Kelvin^2\n"
  },
  "1040.AngularCommand.uavcan": {
    "definition": "#\n# Generic camera gimbal control.\n#\n# This message can only be used in the following modes:\n#  - COMMAND_MODE_ANGULAR_VELOCITY\n#  - COMMAND_MODE_ORIENTATION_FIXED_FRAME\n#  - COMMAND_MODE_ORIENTATION_BODY_FRAME\n#\n\nuint8 gimbal_id\n\n#\n# Target operation mode - how to handle this message.\n# See the list of acceptable modes above.\n#\nMode mode\n\n#\n# In the angular velocity mode, this field contains a rate quaternion.\n# In the orientation mode, this field contains orientation either in fixed frame or in body frame.\n#\nfloat16[4] quaternion_xyzw\n"
  },
  "1041.GEOPOICommand.uavcan": {
    "definition": "#\n# Generic camera gimbal control.\n#\n# This message can only be used in the following modes:\n#  - COMMAND_MODE_GEO_POI\n#\n\nuint8 gimbal_id\n\n#\n# Target operation mode - how to handle this message.\n# See the list of acceptable modes above.\n#\nMode mode\n\n#\n# Coordinates of the POI (point of interest).\n#\nint32 longitude_deg_1e7    # 1 LSB = 1e-7 deg\nint32 latitude_deg_1e7\nint22 height_cm            # 1 LSB = 10 mm\n\nuint2 HEIGHT_REFERENCE_ELLIPSOID = 0\nuint2 HEIGHT_REFERENCE_MEAN_SEA_LEVEL = 1\nuint2 height_reference\n"
  },
  "1044.Status.uavcan": {
    "definition": "#\n# Generic gimbal status.\n#\n\nuint8 gimbal_id\n\nMode mode\n\n#\n# Camera axis orientation in body frame (not in fixed frame).\n# Please refer to the UAVCAN coordinate frame conventions.\n#\nfloat16[4] camera_orientation_in_body_frame_xyzw\nfloat16[<=9] camera_orientation_in_body_frame_covariance   # +inf for non-existent axes\n"
  },
  "Mode.uavcan": {
    "definition": "#\n# Gimbal operating mode\n#\n\nuint8 COMMAND_MODE_ANGULAR_VELOCITY        = 0\nuint8 COMMAND_MODE_ORIENTATION_FIXED_FRAME = 1\nuint8 COMMAND_MODE_ORIENTATION_BODY_FRAME  = 2\nuint8 COMMAND_MODE_GEO_POI                 = 3\nuint8 command_mode\n"
  },
  "Mode": {
    "description": "Gimbal operating mode",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "commandMode",
        "description": ""
      }
    ],
    "statics": [
      "uint8 COMMAND_MODE_ANGULAR_VELOCITY        = 0",
      "uint8 COMMAND_MODE_ORIENTATION_FIXED_FRAME = 1",
      "uint8 COMMAND_MODE_ORIENTATION_BODY_FRAME  = 2",
      "uint8 COMMAND_MODE_GEO_POI                 = 3"
    ]
  },
  "1110.Temperature.uavcan": {
    "definition": "#\n# Generic device temperature\n#\n\nuint16 device_id\n\nfloat16 temperature                  # in kelvin\n\nuint8 ERROR_FLAG_OVERHEATING = 1\nuint8 ERROR_FLAG_OVERCOOLING = 2\nuint8 error_flags\n"
  },
  "1030.RawCommand.uavcan": {
    "definition": "#\n# Raw ESC command normalized into [-8192, 8191]; negative values indicate reverse rotation.\n# The ESC should normalize the setpoint into its effective input range.\n# Non-zero setpoint value below minimum should be interpreted as min valid setpoint for the given motor.\n#\n\nint14[<=20] cmd\n"
  },
  "1031.RPMCommand.uavcan": {
    "definition": "#\n# Simple RPM setpoint.\n# The ESC should automatically clamp the setpoint according to the minimum and maximum supported RPM;\n# for example, given a ESC that operates in the range 100 to 10000 RPM, a setpoint of 1 RPM will be clamped to 100 RPM.\n# Negative values indicate reverse rotation.\n#\n\nint18[<=20] rpm\n"
  },
  "1034.Status.uavcan": {
    "definition": "#\n# Generic ESC status.\n# Unknown fields should be set to NAN.\n#\n\nuint32 error_count          # Resets when the motor restarts\n\nfloat16 voltage             # Volt\nfloat16 current             # Ampere. Can be negative in case of a regenerative braking.\nfloat16 temperature         # Kelvin\n\nint18 rpm                   # Negative value indicates reverse rotation\n\nuint7 power_rating_pct      # Instant demand factor in percent (percent of maximum power); range 0% to 127%.\n\nuint5 esc_index\n"
  },
  "1060.Fix.uavcan": {
    "definition": "#\n# GNSS navigation solution with uncertainty.\n# This message is deprecated. Use the newer 1063.Fix2.uavcan message.\n#\n\nuavcan.Timestamp timestamp         # Global network-synchronized time, if available, otherwise zero\n\n#\n# Time solution.\n# Time standard (GPS, UTC, TAI, etc) is defined in the field below.\n#\nuavcan.Timestamp gnss_timestamp\n\n#\n# Time standard used in the GNSS timestamp field.\n#\nuint3 GNSS_TIME_STANDARD_NONE = 0  # Time is unknown\nuint3 GNSS_TIME_STANDARD_TAI  = 1\nuint3 GNSS_TIME_STANDARD_UTC  = 2\nuint3 GNSS_TIME_STANDARD_GPS  = 3\nuint3 gnss_time_standard\n\nvoid5   # Reserved space\n\n#\n# If known, the number of leap seconds allows to perform conversions between some time standards.\n#\nuint8 NUM_LEAP_SECONDS_UNKNOWN = 0\nuint8 num_leap_seconds\n\n#\n# Position and velocity solution\n#\nint37 longitude_deg_1e8            # Longitude degrees multiplied by 1e8 (approx. 1 mm per LSB)\nint37 latitude_deg_1e8             # Latitude degrees multiplied by 1e8 (approx. 1 mm per LSB on equator)\nint27 height_ellipsoid_mm          # Height above ellipsoid in millimeters\nint27 height_msl_mm                # Height above mean sea level in millimeters\n\nfloat16[3] ned_velocity            # NED frame (north-east-down) in meters per second\n\n#\n# Fix status\n#\nuint6 sats_used\n\nuint2 STATUS_NO_FIX    = 0\nuint2 STATUS_TIME_ONLY = 1\nuint2 STATUS_2D_FIX    = 2\nuint2 STATUS_3D_FIX    = 3\nuint2 status\n\n#\n# Precision\n#\nfloat16 pdop\n\nvoid4\nfloat16[<=9] position_covariance   # m^2\nfloat16[<=9] velocity_covariance   # (m/s)^2\n"
  },
  "1061.Auxiliary.uavcan": {
    "definition": "#\n# GNSS low priority auxiliary info.\n# Unknown DOP parameters should be set to NAN.\n#\n\nfloat16 gdop\nfloat16 pdop\nfloat16 hdop\nfloat16 vdop\nfloat16 tdop\nfloat16 ndop\nfloat16 edop\n\nuint7 sats_visible                    # All visible sats of all available GNSS (e.g. GPS, GLONASS, etc)\nuint6 sats_used                       # All used sats of all available GNSS\n"
  },
  "1062.RTCMStream.uavcan": {
    "definition": "#\n# GNSS RTCM SC-104 protocol raw stream container.\n# RTCM messages that are longer than max data size can be split over multiple consecutive messages.\n#\n\nuint8 PROTOCOL_ID_UNKNOWN = 0\nuint8 PROTOCOL_ID_RTCM2   = 2\nuint8 PROTOCOL_ID_RTCM3   = 3\nuint8 protocol_id\n\nuint8[<=128] data\n"
  },
  "1063.Fix2.uavcan": {
    "definition": "#\n# GNSS ECEF and LLA navigation solution with uncertainty.\n#\n\n#\n# Global network-synchronized time, if available, otherwise zero.\n#\nuavcan.Timestamp timestamp\n\n#\n# Time solution.\n# The method and number of leap seconds which were in use for deriving the timestamp are\n# defined in the fields below.\n#\nuavcan.Timestamp gnss_timestamp\n\n#\n# Method used for deriving the GNSS timestamp field.\n# This data type relies on the following definitions:\n#\n#   Leap seconds  - Accumulated one-second adjustments applied to UTC since 1972.\n#                   For reference, on May 2017, the number of leap seconds was equal 27.\n#                   The number of leap seconds is taken from the field num_leap_seconds.\n#                   Refer to https://en.wikipedia.org/wiki/Leap_second for a general overview.\n#\n#   TAI timestamp - The number of microseconds between the current TAI time and\n#                   the TAI time at UTC 1970-01-01T00:00:00.\n#\n#   UTC timestamp - The number of microseconds between the current UTC time and\n#                   UTC 1970-01-01T00:00:00.\n#                   UTC can be expressed via TAI as follows (in seconds):\n#                       UTC = TAI - num_leap_seconds - 10\n#                   And via GPS (in seconds):\n#                       UTC = GPS - num_leap_seconds + 9\n#\n#   GPS timestamp - The number of microseconds between the current GPS time and\n#                   the GPS time at UTC 1970-01-01T00:00:00.\n#                   GPS time can be expressed via TAI as follows (in seconds):\n#                       GPS = TAI - 19\n#\nuint3 GNSS_TIME_STANDARD_NONE = 0  # Time is unknown\nuint3 GNSS_TIME_STANDARD_TAI  = 1\nuint3 GNSS_TIME_STANDARD_UTC  = 2\nuint3 GNSS_TIME_STANDARD_GPS  = 3\nuint3 gnss_time_standard\n\nvoid13   # Reserved space\n\n#\n# Accumulated one-second adjustments applied to UTC since 1972.\n# The number must agree with the currently correct number of UTC leap seconds. If this cannot\n# be garanteed, the field must be set to NUM_LEAP_SECONDS_UNKNOWN.\n#\nuint8 NUM_LEAP_SECONDS_UNKNOWN = 0\nuint8 num_leap_seconds\n\n#\n# Position and velocity solution\n#\nint37 longitude_deg_1e8            # Longitude degrees multiplied by 1e8 (approx. 1 mm per LSB)\nint37 latitude_deg_1e8             # Latitude degrees multiplied by 1e8 (approx. 1 mm per LSB on equator)\nint27 height_ellipsoid_mm          # Height above ellipsoid in millimeters\nint27 height_msl_mm                # Height above mean sea level in millimeters\n\nfloat32[3] ned_velocity            # NED frame (north-east-down) in meters per second\n\n#\n# Fix status\n#\nuint6 sats_used\n\nuint2 STATUS_NO_FIX    = 0\nuint2 STATUS_TIME_ONLY = 1\nuint2 STATUS_2D_FIX    = 2\nuint2 STATUS_3D_FIX    = 3\nuint2 status\n\n#\n# GNSS Mode\n#\nuint4 MODE_SINGLE      = 0\nuint4 MODE_DGPS        = 1\nuint4 MODE_RTK         = 2\nuint4 MODE_PPP         = 3\nuint4 mode\n\n#\n# GNSS Sub mode\n#\nuint6 SUB_MODE_DGPS_OTHER    = 0\nuint6 SUB_MODE_DGPS_SBAS     = 1\n\nuint6 SUB_MODE_RTK_FLOAT     = 0\nuint6 SUB_MODE_RTK_FIXED     = 1\n\nuint6 sub_mode\n\n#\n# Precision\n#\nfloat16[<=36] covariance    # Position and velocity covariance. Units are\n                            # m^2 for position, (m/s)^2 for velocity and\n                            # m^2/s for position/velocity.\n\nfloat16 pdop\n\n#\n# Position and velocity solution in ECEF, if available\n#\nECEFPositionVelocity[<=1] ecef_position_velocity\n"
  },
  "ECEFPositionVelocity.uavcan": {
    "definition": "#\n# Nested type.\n# GNSS ECEF high resolution position and velocity.\n#\n# ECEF is an acronym for Earth-Centered-Earth-Fixed, which is a cartesian\n# coordinate system which rotates with the earth. The origin (0,0,0) is\n# located at the center of the earth. The x-axis is a vector pointing from\n# the origin with positive direction towards 0 degrees latitude and\n# longitude (equator, at the prime meridian). The z-axis is a vector\n# pointing from the origin towards the north-pole. The y-axis completes a\n# right-handed coordinate system.\n#\n\nfloat32[3] velocity_xyz            # XYZ velocity in m/s\n\nint36[3] position_xyz_mm           # XYZ-axis coordinates in mm\n\nvoid6                              # Aligns the following array at byte boundary\n\nfloat16[<=36] covariance           # Position and velocity covariance in the ECEF frame. Units are m^2 for position,\n                                   # (m/s)^2 for velocity, and m^2/s for position/velocity.\n"
  },
  "ECEFPositionVelocity": {
    "description": "Nested type.\nGNSS ECEF high resolution position and velocity.\nECEF is an acronym for Earth-Centered-Earth-Fixed, which is a cartesian\ncoordinate system which rotates with the earth. The origin (0,0,0) is\nlocated at the center of the earth. The x-axis is a vector pointing from\nthe origin with positive direction towards 0 degrees latitude and\nlongitude (equator, at the prime meridian). The z-axis is a vector\npointing from the origin towards the north-pole. The y-axis completes a\nright-handed coordinate system.",
    "variables": [
      {
        "length": 3,
        "kind": "floatArray",
        "bits": 32,
        "name": "velocityXyz",
        "description": "XYZ velocity in m/s"
      },
      {
        "length": 3,
        "kind": "intArray",
        "bits": 36,
        "name": "positionXyzMm",
        "description": "XYZ-axis coordinates in mm"
      },
      {
        "length": 36,
        "range": true,
        "kind": "floatArray",
        "bits": 16,
        "name": "covariance",
        "description": "Position and velocity covariance in the ECEF frame. Units are m^2 for position,"
      }
    ],
    "statics": []
  },
  "1070.Command.uavcan": {
    "definition": "#\n# Generic cargo holder/hardpoint command.\n#\n\nuint8 hardpoint_id\n\n#\n# Either a binary command (0 - release, 1+ - hold) or bitmask\n#\nuint16 command\n"
  },
  "1071.Status.uavcan": {
    "definition": "#\n# Generic cargo holder/hardpoint status.\n#\n\nuint8 hardpoint_id\n\nfloat16 payload_weight           # Newton\nfloat16 payload_weight_variance\n\n#\n# Meaning is the same as for the command field in the Command message\n#\nuint16 status\n"
  },
  "1129.FuelTankStatus.uavcan": {
    "definition": "#\n# Generic fuel tank status message.\n# All fields are required unless stated otherwise. Unpopulated optional fields should be set to NaN.\n#\n\n#\n# Reserved for future use.\n#\nvoid9\n\n#\n# The estimated amount of fuel.\n# The reported values can be either measured directly using appropriate sensors,\n# or they can be estimated by fusing the data provided by various sensors.\n# For example, a Kalman filter can be used to fuse the data from fuel level sensors and flow sensors.\n# All fields are required.\n#\nuint7 available_fuel_volume_percent     # Unit: percent, from 0% to 100%\nfloat32 available_fuel_volume_cm3       # Unit: centimeter^3\n\n#\n# Estimate of the current fuel consumption rate.\n# The flow can be negative if the fuel is being transferred between the tanks or during refueling.\n# This field is required.\n# Unit: (centimeter^3)/minute\n#\nfloat32 fuel_consumption_rate_cm3pm\n\n#\n# Fuel temperature.\n# This field is optional, set to NaN if not provided.\n# Unit: kelvin\n#\nfloat16 fuel_temperature\n\n#\n# The ID of the current fuel tank.\n#\nuint8 fuel_tank_id\n"
  },
  "1120.Status.uavcan": {
    "definition": "#\n# Generic status message of a piston engine control system.\n#\n# All integer fields are required unless stated otherwise.\n# All floating point fields are optional unless stated otherwise; unknown/unapplicable fields should be set to NaN.\n#\n\n#\n# Abstract engine state. The flags defined below can provide further elaboration.\n# This is a required field.\n#\nuint2 state\n#\n# The engine is not running. This is the default state.\n# Next states: STARTING, FAULT\n#\nuint2 STATE_STOPPED = 0\n#\n# The engine is starting. This is a transient state.\n# Next states: STOPPED, RUNNING, FAULT\n#\nuint2 STATE_STARTING = 1\n#\n# The engine is running normally.\n# Some error flags may be set to indicate non-fatal issues, e.g. overheating.\n# Next states: STOPPED, FAULT\n#\nuint2 STATE_RUNNING = 2\n#\n# The engine can no longer function.\n# The error flags may contain additional information about the nature of the fault.\n# Next states: STOPPED.\n#\nuint2 STATE_FAULT = 3\n\n#\n# General status flags.\n# Note that not all flags are required. Those that aren't are prepended with a validity flag, which is, obviously,\n# always required; when the validity flag is set, it is assumed that the relevant flags are set correctly.\n# If the validity flag is cleared, then the state of the relevant flags should be ignored.\n# All unused bits must be cleared.\n#\nuint30 flags\n#\n# General error. This flag is required, and it can be used to indicate an error condition\n# that does not fit any of the other flags.\n# Note that the vendor may also report additional status information via the vendor specific status code\n# field of the NodeStatus message.\n#\nuint30 FLAG_GENERAL_ERROR                       = 1\n#\n# Error of the crankshaft sensor. This flag is optional.\n#\nuint30 FLAG_CRANKSHAFT_SENSOR_ERROR_SUPPORTED   = 2\nuint30 FLAG_CRANKSHAFT_SENSOR_ERROR             = 4\n#\n# Temperature levels. These flags are optional; either none of them or all of them are supported.\n#\nuint30 FLAG_TEMPERATURE_SUPPORTED               = 8\nuint30 FLAG_TEMPERATURE_BELOW_NOMINAL           = 16      # Under-temperature warning\nuint30 FLAG_TEMPERATURE_ABOVE_NOMINAL           = 32      # Over-temperature warning\nuint30 FLAG_TEMPERATURE_OVERHEATING             = 64      # Critical overheating\nuint30 FLAG_TEMPERATURE_EGT_ABOVE_NOMINAL       = 128     # Exhaust gas over-temperature warning\n#\n# Fuel pressure. These flags are optional; either none of them or all of them are supported.\n#\nuint30 FLAG_FUEL_PRESSURE_SUPPORTED             = 256\nuint30 FLAG_FUEL_PRESSURE_BELOW_NOMINAL         = 512     # Under-pressure warning\nuint30 FLAG_FUEL_PRESSURE_ABOVE_NOMINAL         = 1024    # Over-pressure warning\n#\n# Detonation warning. This flag is optional.\n# This warning is cleared immediately after broadcasting is done if detonation is no longer happening.\n#\nuint30 FLAG_DETONATION_SUPPORTED                = 2048\nuint30 FLAG_DETONATION_OBSERVED                 = 4096    # Detonation condition observed warning\n#\n# Misfire warning. This flag is optional.\n# This warning is cleared immediately after broadcasting is done if misfire is no longer happening.\n#\nuint30 FLAG_MISFIRE_SUPPORTED                   = 8192\nuint30 FLAG_MISFIRE_OBSERVED                    = 16384   # Misfire condition observed warning\n#\n# Oil pressure. These flags are optional; either none of them or all of them are supported.\n#\nuint30 FLAG_OIL_PRESSURE_SUPPORTED              = 32768\nuint30 FLAG_OIL_PRESSURE_BELOW_NOMINAL          = 65536   # Under-pressure warning\nuint30 FLAG_OIL_PRESSURE_ABOVE_NOMINAL          = 131072  # Over-pressure warning\n#\n# Debris warning. This flag is optional.\n#\nuint30 FLAG_DEBRIS_SUPPORTED                    = 262144\nuint30 FLAG_DEBRIS_DETECTED                     = 524288  # Detection of debris warning\n\n#\n# Reserved space\n#\nvoid16\n\n#\n# Engine load estimate.\n# Unit: percent.\n# Range: [0, 127].\n#\nuint7 engine_load_percent\n\n#\n# Engine speed.\n# Unit: revolutions per minute.\n#\nuint17 engine_speed_rpm\n\n#\n# Spark dwell time.\n# Unit: millisecond.\n#\nfloat16 spark_dwell_time_ms\n\n#\n# Atmospheric (barometric) pressure.\n# Unit: kilopascal.\n#\nfloat16 atmospheric_pressure_kpa\n\n#\n# Engine intake manifold pressure.\n# Unit: kilopascal.\n#\nfloat16 intake_manifold_pressure_kpa\n\n#\n# Engine intake manifold temperature.\n# Unit: kelvin.\n#\nfloat16 intake_manifold_temperature\n\n#\n# Engine coolant temperature.\n# Unit: kelvin.\n#\nfloat16 coolant_temperature\n\n#\n# Oil pressure.\n# Unit: kilopascal.\n#\nfloat16 oil_pressure\n\n#\n# Oil temperature.\n# Unit: kelvin.\n#\nfloat16 oil_temperature\n\n#\n# Fuel pressure.\n# Unit: kilopascal.\n#\nfloat16 fuel_pressure\n\n#\n# Instant fuel consumption estimate.\n# The estimated value should be low-pass filtered in order to prevent aliasing effects.\n# Unit: (centimeter^3)/minute.\n#\nfloat32 fuel_consumption_rate_cm3pm\n\n#\n# Estimate of the consumed fuel since the start of the engine.\n# This variable MUST be reset when the engine is stopped.\n# Unit: centimeter^3.\n#\nfloat32 estimated_consumed_fuel_volume_cm3\n\n#\n# Throttle position.\n# Unit: percent.\n#\nuint7 throttle_position_percent\n\n#\n# The index of the publishing ECU.\n#\nuint6 ecu_index\n\n#\n# Spark plug activity report.\n# Can be used during pre-flight tests of the spark subsystem.\n#\nuint3 spark_plug_usage\n#\nuint3 SPARK_PLUG_SINGLE         = 0\nuint3 SPARK_PLUG_FIRST_ACTIVE   = 1\nuint3 SPARK_PLUG_SECOND_ACTIVE  = 2\nuint3 SPARK_PLUG_BOTH_ACTIVE    = 3\n\n#\n# Per-cylinder status information.\n#\nCylinderStatus[<=16] cylinder_status\n"
  },
  "CylinderStatus.uavcan": {
    "definition": "#\n# Cylinder state information.\n# This is a nested data type.\n#\n# All unknown parameters should be set to NaN.\n#\n\n#\n# Cylinder ignition timing.\n# Units: angular degrees of the crankshaft.\n#\nfloat16 ignition_timing_deg\n\n#\n# Fuel injection time.\n# Units: millisecond.\n#\nfloat16 injection_time_ms\n\n#\n# Cylinder head temperature (CHT).\n# Units: kelvin.\n#\nfloat16 cylinder_head_temperature\n\n#\n# Exhaust gas temperature (EGT).\n# Set to NaN if this cylinder is not equipped with an EGT sensor.\n# Set this field to the same value for all cylinders if there is a single shared EGT sensor.\n# Units: kelvin.\n#\nfloat16 exhaust_gas_temperature\n\n#\n# Estimated lambda coefficient.\n# This parameter is mostly useful for monitoring and tuning purposes.\n# Unit: dimensionless ratio\n#\nfloat16 lambda_coefficient\n"
  },
  "CylinderStatus": {
    "description": "Cylinder state information.\nThis is a nested data type.\nAll unknown parameters should be set to NaN.\nCylinder ignition timing.\nUnits: angular degrees of the crankshaft.\nFuel injection time.\nUnits: millisecond.\nCylinder head temperature (CHT).\nUnits: kelvin.\nExhaust gas temperature (EGT).\nSet to NaN if this cylinder is not equipped with an EGT sensor.\nSet this field to the same value for all cylinders if there is a single shared EGT sensor.\nUnits: kelvin.\nEstimated lambda coefficient.\nThis parameter is mostly useful for monitoring and tuning purposes.\nUnit: dimensionless ratio",
    "variables": [
      {
        "kind": "float",
        "bits": 16,
        "name": "ignitionTimingDeg",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "injectionTimeMs",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "cylinderHeadTemperature",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "exhaustGasTemperature",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 16,
        "name": "lambdaCoefficient",
        "description": ""
      }
    ],
    "statics": []
  },
  "1080.BeepCommand.uavcan": {
    "definition": "#\n# Nodes that are capable of producing sounds should obey.\n#\n\nfloat16 frequency  # Hz\nfloat16 duration   # Sec\n"
  },
  "1081.LightsCommand.uavcan": {
    "definition": "#\n# Lights control command.\n#\n\nSingleLightCommand[<=20] commands\n"
  },
  "RGB565.uavcan": {
    "definition": "#\n# Nested type.\n# RGB color in the standard 5-6-5 16-bit palette.\n# Monocolor lights should interpret this as brightness setpoint: from zero (0, 0, 0) to full brightness (31, 63, 31).\n#\n\nuint5 red\nuint6 green\nuint5 blue\n"
  },
  "RGB565": {
    "description": "Nested type.\nRGB color in the standard 5-6-5 16-bit palette.\nMonocolor lights should interpret this as brightness setpoint: from zero (0, 0, 0) to full brightness (31, 63, 31).",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 5,
        "name": "red",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 6,
        "name": "green",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 5,
        "name": "blue",
        "description": ""
      }
    ],
    "statics": []
  },
  "SingleLightCommand.uavcan": {
    "definition": "#\n# Nested type.\n# Controls single light source, color or monochrome.\n#\n\n#\n# Common aircraft lights IDs\n#\n\n# inform the crew working on the apron around noisy airplanes, wearing hearing protection,\n# that the engines are turned on. Also called beacon light\nuint8 LIGHT_ID_ANTI_COLLISION = 246\n\n# a red light is mounted on the left, or port, side of the craft and a green on the right,\n# or starboard, side both 110 degree, and tail white light of 140 degree. Also called navigation lights\nuint8 LIGHT_ID_RIGHT_OF_WAY   = 247\n\n# high-intensity burst of white light, to help other pilots recognize the\n# aircraft's position in low-visibility conditions\nuint8 LIGHT_ID_STROBE         = 248\n\n# positioned on the outer side just in front of the engine cowlings on the fuselage\nuint8 LIGHT_ID_WING           = 249\n\n# lights that highlite on the logo painted on the tail or other visible surface.\n# Also called vertical tail flood lights\nuint8 LIGHT_ID_LOGO           = 250\n\n# help the pilots see the area in front of them and also shows other traffic that they're on the move\nuint8 LIGHT_ID_TAXI           = 251\n\n# light up the area in front of the airplane a bit more towards the side, easier for turns\nuint8 LIGHT_ID_TURN_OFF       = 252\n\n# very bright, lights up the area in front but a lot more than the taxi light\nuint8 LIGHT_ID_TAKE_OFF       = 253\n\n# very bright lights on the wings to help the pilots during landing by\n# lighting up the area where they're going to touch down\nuint8 LIGHT_ID_LANDING        = 254\n\n# usually yellow electroluminescent lightstrips designed to use\n# during formation flying at night or under low visibility conditions\nuint8 LIGHT_ID_FORMATION      = 255\n\nuint8 light_id\n\nRGB565 color      # Monocolor lights should interpret this as brightness\n"
  },
  "SingleLightCommand": {
    "description": "Nested type.\nControls single light source, color or monochrome.\nCommon aircraft lights IDs\ninform the crew working on the apron around noisy airplanes, wearing hearing protection,\nthat the engines are turned on. Also called beacon light\na red light is mounted on the left, or port, side of the craft and a green on the right,\nor starboard, side both 110 degree, and tail white light of 140 degree. Also called navigation lights\nhigh-intensity burst of white light, to help other pilots recognize the\naircraft's position in low-visibility conditions\npositioned on the outer side just in front of the engine cowlings on the fuselage\nlights that highlite on the logo painted on the tail or other visible surface.\nAlso called vertical tail flood lights\nhelp the pilots see the area in front of them and also shows other traffic that they're on the move\nlight up the area in front of the airplane a bit more towards the side, easier for turns\nvery bright, lights up the area in front but a lot more than the taxi light\nvery bright lights on the wings to help the pilots during landing by\nlighting up the area where they're going to touch down\nusually yellow electroluminescent lightstrips designed to use\nduring formation flying at night or under low visibility conditions",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "lightId",
        "description": ""
      }
    ],
    "statics": [
      "uint8 LIGHT_ID_ANTI_COLLISION = 246",
      "uint8 LIGHT_ID_RIGHT_OF_WAY   = 247",
      "uint8 LIGHT_ID_STROBE         = 248",
      "uint8 LIGHT_ID_WING           = 249",
      "uint8 LIGHT_ID_LOGO           = 250",
      "uint8 LIGHT_ID_TAXI           = 251",
      "uint8 LIGHT_ID_TURN_OFF       = 252",
      "uint8 LIGHT_ID_TAKE_OFF       = 253",
      "uint8 LIGHT_ID_LANDING        = 254",
      "uint8 LIGHT_ID_FORMATION      = 255"
    ]
  },
  "1090.PrimaryPowerSupplyStatus.uavcan": {
    "definition": "#\n# Primary power supply status.\n# Typical publishing rate should be around 1~2 Hz.\n#\n\n#\n# How many hours left to full discharge at average load over the last 10 seconds.\n#\nfloat16 hours_to_empty_at_10sec_avg_power               # [Hours]\nfloat16 hours_to_empty_at_10sec_avg_power_variance      # [Hours^2]\n\n#\n# True if the publishing node senses that an external power source can be used, e.g. to charge batteries.\n#\nbool external_power_available\n\n#\n# Remaining energy estimate in percent.\n#\nuint7 remaining_energy_pct              # [Percent]     Required\nuint7 remaining_energy_pct_stdev        # [Percent]     Error standard deviation. Use best guess if unknown.\n"
  },
  "1091.CircuitStatus.uavcan": {
    "definition": "#\n# Generic electrical circuit info.\n#\n\nuint16 circuit_id\n\nfloat16 voltage\nfloat16 current\n\nuint8 ERROR_FLAG_OVERVOLTAGE  = 1\nuint8 ERROR_FLAG_UNDERVOLTAGE = 2\nuint8 ERROR_FLAG_OVERCURRENT  = 4\nuint8 ERROR_FLAG_UNDERCURRENT = 8\nuint8 error_flags\n"
  },
  "1092.BatteryInfo.uavcan": {
    "definition": "#\n# Single battery info.\n#\n# Typical publishing rate should be around 0.2~1 Hz.\n#\n# Please refer to the Smart Battery data specification for some elaboration.\n#\n\n#\n# Primary parameters.\n# Some fields can be set to NAN if their values are unknown.\n# Full charge capacity is expected to slowly reduce as the battery is aging. Normally its estimate is updated after\n# every charging cycle.\n#\nfloat16 temperature             # [Kelvin]\nfloat16 voltage                 # [Volt]\nfloat16 current                 # [Ampere]\nfloat16 average_power_10sec     # [Watt]        Average power consumption over the last 10 seconds\nfloat16 remaining_capacity_wh   # [Watt hours]  Will be increasing during charging\nfloat16 full_charge_capacity_wh # [Watt hours]  Predicted battery capacity when it is fully charged. Falls with aging\nfloat16 hours_to_full_charge    # [Hours]       Charging is expected to complete in this time; zero if not charging\n\n#\n# Status flags.\n# Notes:\n#  - CHARGING must be always set as long as the battery is connected to a charger, even if the charging is complete.\n#  - CHARGED must be cleared immediately when the charger is disconnected.\n#\nuint11 STATUS_FLAG_IN_USE       = 1     # The battery is currently used as a power supply\nuint11 STATUS_FLAG_CHARGING     = 2     # Charger is active\nuint11 STATUS_FLAG_CHARGED      = 4     # Charging complete, but the charger is still active\nuint11 STATUS_FLAG_TEMP_HOT     = 8     # Battery temperature is above normal\nuint11 STATUS_FLAG_TEMP_COLD    = 16    # Battery temperature is below normal\nuint11 STATUS_FLAG_OVERLOAD     = 32    # Safe operating area violation\nuint11 STATUS_FLAG_BAD_BATTERY  = 64    # This battery should not be used anymore (e.g. low SOH)\nuint11 STATUS_FLAG_NEED_SERVICE = 128   # This battery requires maintenance (e.g. balancing, full recharge)\nuint11 STATUS_FLAG_BMS_ERROR    = 256   # Battery management system/controller error, smart battery interface error\nuint11 STATUS_FLAG_RESERVED_A   = 512   # Keep zero\nuint11 STATUS_FLAG_RESERVED_B   = 1024  # Keep zero\nuint11 status_flags\n\n#\n# State of Health (SOH) estimate, in percent.\n# http://en.wikipedia.org/wiki/State_of_health\n#\nuint7 STATE_OF_HEALTH_UNKNOWN = 127     # Use this constant if SOH cannot be estimated\nuint7 state_of_health_pct               # Health of the battery, in percent, optional\n\n#\n# Relative State of Charge (SOC) estimate, in percent.\n# http://en.wikipedia.org/wiki/State_of_charge\n#\nuint7 state_of_charge_pct               # Percent of the full charge [0, 100]. This field is required\nuint7 state_of_charge_pct_stdev         # SOC error standard deviation; use best guess if unknown\n\n#\n# Battery identification.\n# Model instance ID must be unique within the same battery model name.\n# Model name is a human-readable string that normally should include the vendor name, model name, and chemistry\n# type of this battery. This field should be assumed case-insensitive. Example: \"Zubax Smart Battery v1.1 LiPo\".\n#\nuint8 battery_id                        # Identifies the battery within this vehicle, e.g. 0 - primary battery\nuint32 model_instance_id                # Set to zero if not applicable\nuint8[<32] model_name                   # Battery model name\n"
  },
  "1050.Measurement.uavcan": {
    "definition": "#\n# Generic narrow-beam range sensor data.\n#\n\nuavcan.Timestamp timestamp\n\nuint8 sensor_id\n\nuavcan.CoarseOrientation beam_orientation_in_body_frame\n\nfloat16 field_of_view                # Radians\n\nuint5 SENSOR_TYPE_UNDEFINED = 0\nuint5 SENSOR_TYPE_SONAR     = 1\nuint5 SENSOR_TYPE_LIDAR     = 2\nuint5 SENSOR_TYPE_RADAR     = 3\nuint5 sensor_type\n\nuint3 READING_TYPE_UNDEFINED   = 0   # Range is unknown\nuint3 READING_TYPE_VALID_RANGE = 1   # Range field contains valid distance\nuint3 READING_TYPE_TOO_CLOSE   = 2   # Range field contains min range for the sensor\nuint3 READING_TYPE_TOO_FAR     = 3   # Range field contains max range for the sensor\nuint3 reading_type\n\nfloat16 range                        # Meters\n"
  },
  "1100.ArmingStatus.uavcan": {
    "definition": "#\n# This message represents the system arming status.\n# Some nodes may refuse to operate unless the system is fully armed.\n#\n\nuint8 STATUS_DISARMED           = 0\nuint8 STATUS_FULLY_ARMED        = 255\n\nuint8 status\n"
  },
  "2000.GlobalNavigationSolution.uavcan": {
    "definition": "#\n# Inertial data and orientation in body frame with fused location.\n#\n# Fields marked as optional should be set to NaN if the corresponding value is unknown.\n#\n\n#\n# Global network synchronized timestamp, if known.\n# Set to zero if the timestamp is not known.\n#\nuavcan.Timestamp timestamp\n\n#\n# Geo location [angular degree].\n#\nfloat64 longitude                   # required\nfloat64 latitude                    # required\n\n#\n# Height estimates [meter].\n#\nfloat32 height_ellipsoid            # Above ellipsoid (required)\nfloat32 height_msl                  # Above the mean sea level (required)\nfloat32 height_agl                  # Above ground level (provided by radar altimeter or LIDAR) (optional)\nfloat32 height_baro                 # Barometric height (optional)\n\n#\n# Atmospheric pressure adjusted to sea level [hectopascal].\n#\nfloat16 qnh_hpa                     # optional\n\n#\n# Rotation quaternion between the NED frame and the body frame.\n# Zero rotation corresponds to the following orientation:\n#   X facing north\n#   Y facing east\n#   Z facing down\n#\nfloat32[4] orientation_xyzw\n\n#\n# Column order:\n#   longitude                                   [meter^2]\n#   latitude                                    [meter^2]\n#   height (MSL or ellipsoid, whichever worse)  [meter^2]\n#   roll angle                                  [radian^2]\n#   pitch angle                                 [radian^2]\n#   yaw angle                                   [radian^2]\n#\nfloat16[<=36] pose_covariance\n\n#\n# Linear velocity in the body frame, X-Y-Z [meter/second].\n#\nfloat32[3] linear_velocity_body\n\n#\n# Angular velocity in the body frame, roll-pitch-yaw [radian/second].\n#\nfloat32[3] angular_velocity_body\n\n#\n# Low resolution estimate of the linear acceleration in the body frame [(meter/second)^2].\n# This estimate should be properly downsampled in order to avoid aliasing effects.\n#\nfloat16[3] linear_acceleration_body\n\n#\n# Column order:\n#   X velocity      [(meter/second)^2]\n#   Y velocity      [(meter/second)^2]\n#   Z velocity      [(meter/second)^2]\n#   roll velocity   [(radian/second)^2]\n#   pitch velocity  [(radian/second)^2]\n#   yaw velocity    [(radian/second)^2]\n#\nfloat16[<=36] velocity_covariance\n"
  },
  "1.GetNodeInfo.uavcan": {
    "definition": "#\n# Full node info request.\n# Note that all fields of the response section are byte-aligned.\n#\n\n---\n\n#\n# Current node status\n#\nNodeStatus status\n\n#\n# Version information shall not be changed while the node is running.\n#\nSoftwareVersion software_version\nHardwareVersion hardware_version\n\n#\n# Human readable non-empty ASCII node name.\n# Node name shall not be changed while the node is running.\n# Empty string is not a valid node name.\n# Allowed characters are: a-z (lowercase ASCII letters) 0-9 (decimal digits) . (dot) - (dash) _ (underscore).\n# Node name is a reversed internet domain name (like Java packages), e.g. \"com.manufacturer.project.product\".\n#\nuint8[<=80] name\n"
  },
  "2.GetDataTypeInfo.uavcan": {
    "definition": "#\n# Get the implementation details of a given data type.\n#\n# Request is interpreted as follows:\n#  - If the field 'name' is empty, the fields 'kind' and 'id' will be used to identify the data type.\n#  - If the field 'name' is non-empty, it will be used to identify the data type; the\n#    fields 'kind' and 'id' will be ignored.\n#\n\nuint16 id                   # Ignored if 'name' is non-empty\nDataTypeKind kind           # Ignored if 'name' is non-empty\n\nuint8[<=80] name            # Full data type name, e.g. \"uavcan.protocol.GetDataTypeInfo\"\n\n---\n\nuint64 signature            # Data type signature; valid only if the data type is known (see FLAG_KNOWN)\n\nuint16 id                   # Valid only if the data type is known (see FLAG_KNOWN)\nDataTypeKind kind           # Ditto\n\nuint8 FLAG_KNOWN      = 1   # This data type is defined\nuint8 FLAG_SUBSCRIBED = 2   # Subscribed to messages of this type\nuint8 FLAG_PUBLISHING = 4   # Publishing messages of this type\nuint8 FLAG_SERVING    = 8   # Providing service of this type\nuint8 flags\n\nuint8[<=80] name            # Full data type name\n"
  },
  "341.NodeStatus.uavcan": {
    "definition": "#\n# Abstract node status information.\n#\n# All UAVCAN nodes are required to publish this message periodically.\n#\n\n#\n# Publication period may vary within these limits.\n# It is NOT recommended to change it at run time.\n#\nuint16 MAX_BROADCASTING_PERIOD_MS = 1000\nuint16 MIN_BROADCASTING_PERIOD_MS = 2\n\n#\n# If a node fails to publish this message in this amount of time, it should be considered offline.\n#\nuint16 OFFLINE_TIMEOUT_MS = 3000\n\n#\n# Uptime counter should never overflow.\n# Other nodes may detect that a remote node has restarted when this value goes backwards.\n#\nuint32 uptime_sec\n\n#\n# Abstract node health.\n#\nuint2 HEALTH_OK         = 0     # The node is functioning properly.\nuint2 HEALTH_WARNING    = 1     # A critical parameter went out of range or the node encountered a minor failure.\nuint2 HEALTH_ERROR      = 2     # The node encountered a major failure.\nuint2 HEALTH_CRITICAL   = 3     # The node suffered a fatal malfunction.\nuint2 health\n\n#\n# Current mode.\n#\n# Mode OFFLINE can be actually reported by the node to explicitly inform other network\n# participants that the sending node is about to shutdown. In this case other nodes will not\n# have to wait OFFLINE_TIMEOUT_MS before they detect that the node is no longer available.\n#\n# Reserved values can be used in future revisions of the specification.\n#\nuint3 MODE_OPERATIONAL      = 0         # Normal operating mode.\nuint3 MODE_INITIALIZATION   = 1         # Initialization is in progress; this mode is entered immediately after startup.\nuint3 MODE_MAINTENANCE      = 2         # E.g. calibration, the bootloader is running, etc.\nuint3 MODE_SOFTWARE_UPDATE  = 3         # New software/firmware is being loaded.\nuint3 MODE_OFFLINE          = 7         # The node is no longer available.\nuint3 mode\n\n#\n# Not used currently, keep zero when publishing, ignore when receiving.\n#\nuint3 sub_mode\n\n#\n# Optional, vendor-specific node status code, e.g. a fault code or a status bitmask.\n#\nuint16 vendor_specific_status_code\n"
  },
  "4.GetTransportStats.uavcan": {
    "definition": "#\n# Get transport statistics.\n#\n\n---\n\n#\n# UAVCAN transport layer statistics.\n#\nuint48 transfers_tx             # Number of transmitted transfers.\nuint48 transfers_rx             # Number of received transfers.\nuint48 transfer_errors          # Number of errors detected in the UAVCAN transport layer.\n\n#\n# CAN bus statistics, for each interface independently.\n#\nCANIfaceStats[<=3] can_iface_stats\n"
  },
  "4.GlobalTimeSync.uavcan": {
    "definition": "#\n# Global time synchronization.\n# Any node that publishes timestamped data must use this time reference.\n#\n# Please refer to the specification to learn about the synchronization algorithm.\n#\n\n#\n# Broadcasting period must be within this range.\n#\nuint16 MAX_BROADCASTING_PERIOD_MS = 1100            # Milliseconds\nuint16 MIN_BROADCASTING_PERIOD_MS = 40              # Milliseconds\n\n#\n# Synchronization slaves may switch to a new source if the current master was silent for this amount of time.\n#\nuint16 RECOMMENDED_BROADCASTER_TIMEOUT_MS = 2200    # Milliseconds\n\n#\n# Time in microseconds when the PREVIOUS GlobalTimeSync message was transmitted.\n# If this message is the first one, this field must be zero.\n#\ntruncated uint56 previous_transmission_timestamp_usec # Microseconds\n"
  },
  "5.Panic.uavcan": {
    "definition": "#\n# This message may be published periodically to inform network participants that the system has encountered\n# an unrecoverable fault and is not capable of further operation.\n#\n# Nodes that are expected to react to this message should wait for at least MIN_MESSAGES subsequent messages\n# with any reason text from any sender published with the interval no higher than MAX_INTERVAL_MS before\n# undertaking any emergency actions.\n#\n\nuint8 MIN_MESSAGES = 3\n\nuint16 MAX_INTERVAL_MS = 500\n\n#\n# Short description that would fit a single CAN frame.\n#\nuint8[<=7] reason_text\n"
  },
  "5.RestartNode.uavcan": {
    "definition": "#\n# Restart the node.\n#\n# Some nodes may require restart before the new configuration will be applied.\n#\n# The request should be rejected if magic_number does not equal MAGIC_NUMBER.\n#\n\nuint40 MAGIC_NUMBER = 0xACCE551B1E\nuint40 magic_number\n\n---\n\nbool ok\n"
  },
  "6.AccessCommandShell.uavcan": {
    "definition": "#\n# THIS DEFINITION IS SUBJECT TO CHANGE.\n#\n# This service allows to execute arbitrary commands on the remote node's internal system shell.\n#\n# Essentially, this service mimics a typical terminal emulator, with one text input (stdin) and two text\n# outputs (stdout and stderr). When there's no process running, the input is directed into the terminal\n# handler itself, which interprets it. If there's a process running, the input will be directed into\n# stdin of the running process. It is possible to forcefully return the terminal into a known state by\n# means of setting the reset flag (see below), in which case the terminal will kill all of the child\n# processes, if any, and return into the initial idle state.\n#\n# The server is assumed to allocate one independent terminal instance per client, so that different clients\n# can execute commands without interfering with each other.\n#\n\n#\n# Input and output should use this newline character.\n#\nuint8 NEWLINE = '\\n'\n\n#\n# The server is required to keep the result of the last executed command for at least this time.\n# When this time expires, the server may remove the results in order to reclaim the memory, but it\n# is not guaranteed. Hence, the clients must retrieve the results in this amount of time.\n#\nuint8 MIN_OUTPUT_LIFETIME_SEC = 10\n\n#\n# These flags control the shell and command execution.\n#\nuint8 FLAG_RESET_SHELL          = 1     # Restarts the shell instance anew; may or may not imply CLEAR_OUTPUT_BUFFERS\nuint8 FLAG_CLEAR_OUTPUT_BUFFERS = 2     # Makes stdout and stderr buffers empty\nuint8 FLAG_READ_STDOUT          = 64    # Output will contain stdout\nuint8 FLAG_READ_STDERR          = 128   # Output will be extended with stderr\nuint8 flags\n\n#\n# If the shell is idle, it will interpret this string.\n# If there's a process running, this string will be piped into its stdin.\n#\n# If RESET_SHELL is set, new input will be interpreted by the shell immediately.\n#\nuint8[<=128] input\n\n---\n\n#\n# Exit status of the last executed process, or error code of the shell itself.\n# Default value is zero.\n#\nint32 last_exit_status\n\n#\n# These flags indicate the status of the shell.\n#\nuint8 FLAG_RUNNING              = 1     # The shell is currently running a process; stdin/out/err are piped to it\nuint8 FLAG_SHELL_ERROR          = 2     # Exit status contains error code, output contains text (e.g. no such command)\nuint8 FLAG_HAS_PENDING_STDOUT   = 64    # There is more stdout to read\nuint8 FLAG_HAS_PENDING_STDERR   = 128   # There is more stderr to read\nuint8 flags\n\n#\n# In case of a shell error, this string may contain ASCII string explaining the nature of the error.\n# Otherwise, if stdout read is requested, this string will contain stdout data. If stderr read is requested,\n# this string will contain stderr data. If both stdout and stderr read is requested, this string will start\n# with stdout and end with stderr, with no separator in between.\n#\nuint8[<=256] output\n"
  },
  "CANIfaceStats.uavcan": {
    "definition": "#\n# Single CAN iface statistics.\n#\n\nuint48 frames_tx        # Number of transmitted CAN frames.\nuint48 frames_rx        # Number of received CAN frames.\nuint48 errors           # Number of errors in the CAN layer.\n"
  },
  "CANIfaceStats": {
    "description": "Single CAN iface statistics.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 48,
        "name": "framesTx",
        "description": "Number of transmitted CAN frames."
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 48,
        "name": "framesRx",
        "description": "Number of received CAN frames."
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 48,
        "name": "errors",
        "description": "Number of errors in the CAN layer."
      }
    ],
    "statics": []
  },
  "DataTypeKind.uavcan": {
    "definition": "#\n# Data type kind (message or service).\n#\n\nuint8 SERVICE = 0\nuint8 MESSAGE = 1\nuint8 value\n"
  },
  "DataTypeKind": {
    "description": "Data type kind (message or service).",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "value",
        "description": ""
      }
    ],
    "statics": [
      "uint8 SERVICE = 0",
      "uint8 MESSAGE = 1"
    ]
  },
  "HardwareVersion.uavcan": {
    "definition": "#\n# Nested type.\n# Generic hardware version information.\n# These values should remain unchanged for the device's lifetime.\n#\n\n#\n# Hardware version code.\n#\nuint8 major\nuint8 minor\n\n#\n# Unique ID is a 128 bit long sequence that is globally unique for each node.\n# All zeros is not a valid UID.\n# If filled with zeros, assume that the value is undefined.\n#\nuint8[16] unique_id\n\n#\n# Certificate of authenticity (COA) of the hardware, 255 bytes max.\n#\nuint8[<=255] certificate_of_authenticity\n"
  },
  "HardwareVersion": {
    "description": "Nested type.\nGeneric hardware version information.\nThese values should remain unchanged for the device's lifetime.\nHardware version code.\nUnique ID is a 128 bit long sequence that is globally unique for each node.\nAll zeros is not a valid UID.\nIf filled with zeros, assume that the value is undefined.\nCertificate of authenticity (COA) of the hardware, 255 bytes max.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "major",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "minor",
        "description": ""
      },
      {
        "length": 16,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "uniqueId",
        "description": ""
      },
      {
        "length": 255,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "certificateOfAuthenticity",
        "description": ""
      }
    ],
    "statics": []
  },
  "SoftwareVersion.uavcan": {
    "definition": "#\n# Nested type.\n# Generic software version information.\n#\n\n#\n# Primary version numbers.\n# If both fields are set to zero, the version is considered unknown.\n#\nuint8 major\nuint8 minor\n\n#\n# This mask indicates which optional fields (see below) are set.\n#\nuint8 OPTIONAL_FIELD_FLAG_VCS_COMMIT = 1\nuint8 OPTIONAL_FIELD_FLAG_IMAGE_CRC  = 2\nuint8 optional_field_flags\n\n#\n# VCS commit hash or revision number, e.g. git short commit hash. Optional.\n#\nuint32 vcs_commit\n\n#\n# The value of an arbitrary hash function applied to the firmware image.\n# This field is used to detect whether the firmware running on the node is EXACTLY THE SAME\n# as a certain specific revision. This field provides the absolute identity guarantee, unlike\n# the version fields above, which can be the same for different builds of the firmware.\n#\n# The exact hash function and the methods of its application are implementation defined.\n# However, implementations are recommended to adhere to the following guidelines,\n# fully or partially:\n#\n#   - The hash function should be CRC-64-WE, the same that is used for computing DSDL signatures.\n#\n#   - The hash function should be applied to the entire application image padded to 8 bytes.\n#\n#   - If the computed image CRC is stored within the firmware image itself, the value of\n#     the hash function becomes ill-defined, because it becomes recursively dependent on itself.\n#     In order to circumvent this issue, while computing or checking the CRC, its value stored\n#     within the image should be zeroed out.\n#\nuint64 image_crc\n"
  },
  "SoftwareVersion": {
    "description": "Nested type.\nGeneric software version information.\nPrimary version numbers.\nIf both fields are set to zero, the version is considered unknown.\nThis mask indicates which optional fields (see below) are set.\nVCS commit hash or revision number, e.g. git short commit hash. Optional.\nThe value of an arbitrary hash function applied to the firmware image.\nThis field is used to detect whether the firmware running on the node is EXACTLY THE SAME\nas a certain specific revision. This field provides the absolute identity guarantee, unlike\nthe version fields above, which can be the same for different builds of the firmware.\nThe exact hash function and the methods of its application are implementation defined.\nHowever, implementations are recommended to adhere to the following guidelines,\nfully or partially:\n  - The hash function should be CRC-64-WE, the same that is used for computing DSDL signatures.\n  - The hash function should be applied to the entire application image padded to 8 bytes.\n  - If the computed image CRC is stored within the firmware image itself, the value of\n    the hash function becomes ill-defined, because it becomes recursively dependent on itself.\n    In order to circumvent this issue, while computing or checking the CRC, its value stored\n    within the image should be zeroed out.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "major",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "minor",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "optionalFieldFlags",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "vcsCommit",
        "description": ""
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 64,
        "name": "imageCrc",
        "description": ""
      }
    ],
    "statics": [
      "uint8 OPTIONAL_FIELD_FLAG_VCS_COMMIT = 1",
      "uint8 OPTIONAL_FIELD_FLAG_IMAGE_CRC  = 2"
    ]
  },
  "16370.KeyValue.uavcan": {
    "definition": "#\n# Generic named parameter (key/value pair).\n#\n\n#\n# Integers are exactly representable in the range (-2^24, 2^24) which is (-16'777'216, 16'777'216).\n#\nfloat32 value\n\n#\n# Tail array optimization is enabled, so if key length does not exceed 3 characters, the whole\n# message can fit into one CAN frame. The message always fits into one CAN FD frame.\n#\nuint8[<=58] key\n"
  },
  "16383.LogMessage.uavcan": {
    "definition": "#\n# Generic log message.\n# All items are byte aligned.\n#\n\nLogLevel level\nuint8[<=31] source\nuint8[<=90] text\n"
  },
  "LogLevel.uavcan": {
    "definition": "#\n# Log message severity\n#\n\nuint3 DEBUG    = 0\nuint3 INFO     = 1\nuint3 WARNING  = 2\nuint3 ERROR    = 3\nuint3 value\n"
  },
  "LogLevel": {
    "description": "Log message severity",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 3,
        "name": "value",
        "description": ""
      }
    ],
    "statics": [
      "uint3 DEBUG    = 0",
      "uint3 INFO     = 1",
      "uint3 WARNING  = 2",
      "uint3 ERROR    = 3"
    ]
  },
  "1.Allocation.uavcan": {
    "definition": "#\n# This message is used for dynamic Node ID allocation.\n#\n# When a node needs to request a node ID dynamically, it will transmit an anonymous message transfer of this type.\n# In order to reduce probability of CAN ID collisions when multiple nodes are publishing this request, the CAN ID\n# field of anonymous message transfer includes a Discriminator, which is a special field that has to be filled with\n# random data by the transmitting node. Since Discriminator collisions are likely to happen (probability approx.\n# 0.006%), nodes that are requesting dynamic allocations need to be able to handle them correctly. Hence, a collision\n# resolution protocol is defined (alike CSMA/CD). The collision resolution protocol is based on two randomized\n# transmission intervals:\n#\n# - Request period - Trequest.\n# - Follow up delay - Tfollowup.\n#\n# Recommended randomization ranges for these intervals are documented in the constants of this message type (see below).\n# Random intervals must be chosen anew per transmission, whereas the Discriminator value is allowed to stay constant\n# per node.\n#\n# In the below description the following terms are used:\n# - Allocator - the node that serves allocation requests.\n# - Allocatee - the node that requests an allocation from the Allocator.\n#\n# The response timeout is not explicitly defined for this protocol, as the Allocatee will request the allocation\n# Trequest units of time later again, unless the allocation has been granted. Despite this, the implementation can\n# consider the value of FOLLOWUP_TIMEOUT_MS as an allocation timeout, if necessary.\n#\n# On the allocatee's side the protocol is defined through the following set of rules:\n#\n# Rule A. On initialization:\n# 1. The allocatee subscribes to this message.\n# 2. The allocatee starts the Request Timer with a random interval of Trequest.\n#\n# Rule B. On expiration of Request Timer:\n# 1. Request Timer restarts with a random interval of Trequest.\n# 2. The allocatee broadcasts a first-stage Allocation request message, where the fields are assigned following values:\n#    node_id                 - preferred node ID, or zero if the allocatee doesn't have any preference\n#    first_part_of_unique_id - true\n#    unique_id               - first MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST bytes of unique ID\n#\n# Rule C. On any Allocation message, even if other rules also match:\n# 1. Request Timer restarts with a random interval of Trequest.\n#\n# Rule D. On an Allocation message WHERE (source node ID is non-anonymous) AND (allocatee's unique ID starts with the\n# bytes available in the field unique_id) AND (unique_id is less than 16 bytes long):\n# 1. The allocatee waits for Tfollowup units of time, while listening for other Allocation messages. If an Allocation\n#    message is received during this time, the execution of this rule will be terminated. Also see rule C.\n# 2. The allocatee broadcasts a second-stage Allocation request message, where the fields are assigned following values:\n#    node_id                 - same value as in the first-stage\n#    first_part_of_unique_id - false\n#    unique_id               - at most MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST bytes of local unique ID with an offset\n#                              equal to number of bytes in the received unique ID\n#\n# Rule E. On an Allocation message WHERE (source node ID is non-anonymous) AND (unique_id fully matches allocatee's\n# unique ID) AND (node_id in the received message is not zero):\n# 1. Request Timer stops.\n# 2. The allocatee initializes its node_id with the received value.\n# 3. The allocatee terminates subscription to Allocation messages.\n# 4. Exit.\n#\n\n#\n# Recommended randomization range for request period.\n#\n# These definitions have an advisory status; it is OK to pick higher values for both bounds, as it won't affect\n# protocol compatibility. In fact, it is advised to pick higher values if the target application is not concerned\n# about the time it will spend on completing the dynamic node ID allocation procedure, as it will reduce\n# interference with other nodes, possibly of higher importance.\n#\n# The lower bound shall not be lower than FOLLOWUP_TIMEOUT_MS, otherwise the request may conflict with a followup.\n#\nuint16 MAX_REQUEST_PERIOD_MS = 1000     # It is OK to exceed this value\nuint16 MIN_REQUEST_PERIOD_MS = 600      # It is OK to exceed this value\n\n#\n# Recommended randomization range for followup delay.\n# The upper bound shall not exceed FOLLOWUP_TIMEOUT_MS, because the allocator will reset the state on its end.\n#\nuint16 MAX_FOLLOWUP_DELAY_MS = 400\nuint16 MIN_FOLLOWUP_DELAY_MS = 0        # Defined only for regularity; will always be zero.\n\n#\n# Allocator will reset its state if there was no follow-up request in this amount of time.\n#\nuint16 FOLLOWUP_TIMEOUT_MS = 500\n\n#\n# Any request message can accommodate no more than this number of bytes of unique ID.\n# This limitation is needed to ensure that all request transfers are single-frame.\n# This limitation does not apply to CAN FD transport.\n#\nuint8 MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST = 6\n\n#\n# When requesting an allocation, set the field 'node_id' to this value if there's no preference.\n#\nuint7 ANY_NODE_ID = 0\n\n#\n# If transfer is anonymous, this is the preferred ID.\n# If transfer is non-anonymous, this is allocated ID.\n#\n# If the allocatee does not have any preference, this value must be set to zero. In this case, the allocator\n# must choose the highest unused node ID value for this allocation (except 126 and 127, that are reserved for\n# network maintenance tools). E.g., if the allocation table is empty and the node has requested an allocation\n# without any preference, the allocator will grant the node ID 125.\n#\n# If the preferred node ID is not zero, the allocator will traverse the allocation table starting from the\n# preferred node ID upward, until a free node ID is found. If a free node ID could not be found, the\n# allocator will restart the search from the preferred node ID downward, until a free node ID is found.\n#\n# In pseudocode:\n#   int findFreeNodeID(const int preferred)\n#   {\n#       // Search up\n#       int candidate = (preferred > 0) ? preferred : 125;\n#       while (candidate <= 125)\n#       {\n#           if (!isOccupied(candidate))\n#               return candidate;\n#           candidate++;\n#       }\n#       // Search down\n#       candidate = (preferred > 0) ? preferred : 125;\n#       while (candidate > 0)\n#       {\n#           if (!isOccupied(candidate))\n#               return candidate;\n#           candidate--;\n#       }\n#       // Not found\n#       return -1;\n#   }\n#\nuint7 node_id\n\n#\n# If transfer is anonymous, this field indicates first-stage request.\n# If transfer is non-anonymous, this field should be assigned zero and ignored.\n#\nbool first_part_of_unique_id\n\n#\n# If transfer is anonymous, this array must not contain more than MAX_LENGTH_OF_UNIQUE_ID_IN_REQUEST items.\n# Note that array is tail-optimized, i.e. it will not be prepended with length field.\n#\nuint8[<=16] unique_id\n"
  },
  "30.AppendEntries.uavcan": {
    "definition": "#\n# THIS DEFINITION IS SUBJECT TO CHANGE.\n#\n# This type is a part of the Raft consensus algorithm.\n# Please refer to the specification for details.\n#\n\n#\n# Given min election timeout and cluster size, the maximum recommended request interval can be derived as follows:\n#\n#   max recommended request interval = (min election timeout) / 2 requests / (cluster size - 1)\n#\n# The equation assumes that the Leader requests one Follower at a time, so that there's at most one pending call\n# at any moment. Such behavior is optimal as it creates uniform bus load, but it is actually implementation-specific.\n# Obviously, request interval can be lower than that if needed, but higher values are not recommended as they may\n# cause Followers to initiate premature elections in case of intensive frame losses or delays.\n#\n# Real timeout is randomized in the range (MIN, MAX], according to the Raft paper.\n#\nuint16 DEFAULT_MIN_ELECTION_TIMEOUT_MS = 2000\nuint16 DEFAULT_MAX_ELECTION_TIMEOUT_MS = 4000\n\n#\n# Refer to the Raft paper for explanation.\n#\nuint32 term\nuint32 prev_log_term\nuint8 prev_log_index\nuint8 leader_commit\n\n#\n# Worst-case replication time per Follower can be computed as:\n#\n#   worst replication time = (127 log entries) * (2 trips of next_index) * (request interval per Follower)\n#\nEntry[<=1] entries\n\n---\n\n#\n# Refer to the Raft paper for explanation.\n#\nuint32 term\nbool success\n"
  },
  "31.RequestVote.uavcan": {
    "definition": "#\n# THIS DEFINITION IS SUBJECT TO CHANGE.\n#\n# This type is a part of the Raft consensus algorithm.\n# Please refer to the specification for details.\n#\n\n#\n# Refer to the Raft paper for explanation.\n#\nuint32 term\nuint32 last_log_term\nuint8 last_log_index\n\n---\n\n#\n# Refer to the Raft paper for explanation.\n#\nuint32 term\nbool vote_granted\n"
  },
  "390.Discovery.uavcan": {
    "definition": "#\n# THIS DEFINITION IS SUBJECT TO CHANGE.\n#\n# This message is used by allocation servers to find each other's node ID.\n# Please refer to the specification for details.\n#\n# A server should stop publishing this message as soon as it has discovered all other nodes in the cluster.\n#\n# An exception applies: when a server receives a Discovery message from another server where the list\n# of known nodes is incomplete (i.e. len(known_nodes) < configured_cluster_size), the server must\n# publish a discovery message once. This condition allows other servers to quickly re-discover the cluster\n# after restart.\n#\n\n#\n# This message should be broadcasted by the server at this interval until all other servers are discovered.\n#\nuint16 BROADCASTING_PERIOD_MS = 1000\n\n#\n# Number of servers in the cluster as configured on the sender.\n#\nuint8 configured_cluster_size\n\n#\n# Node ID of servers that are known to the publishing server, including the publishing server itself.\n# Capacity of this array defines maximum size of the server cluster.\n#\nuint8[<=5] known_nodes\n"
  },
  "Entry.uavcan": {
    "definition": "#\n# THIS DEFINITION IS SUBJECT TO CHANGE.\n#\n# One dynamic node ID allocation entry.\n# This type is a part of the Raft consensus algorithm.\n# Please refer to the specification for details.\n#\n\nuint32 term             # Refer to the Raft paper for explanation.\n\nuint8[16] unique_id     # Unique ID of this allocation.\n\nvoid1\nuint7 node_id           # Node ID of this allocation.\n"
  },
  "Entry": {
    "description": "THIS DEFINITION IS SUBJECT TO CHANGE.\nOne dynamic node ID allocation entry.\nThis type is a part of the Raft consensus algorithm.\nPlease refer to the specification for details.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 32,
        "name": "term",
        "description": "Refer to the Raft paper for explanation."
      },
      {
        "length": 16,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "uniqueId",
        "description": "Unique ID of this allocation."
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 7,
        "name": "nodeId",
        "description": "Node ID of this allocation."
      }
    ],
    "statics": []
  },
  "15.Begin.uavcan": {
    "definition": "#\n# This service instructs the node to begin the process of automated enumeration.\n#\n\n#\n# The node will automatically leave enumeration mode upon expiration of this timeout.\n#\nuint16 TIMEOUT_CANCEL   = 0     # Stop enumeration immediately\nuint16 TIMEOUT_INFINITE = 65535 # Do not stop until explicitly requested\nuint16 timeout_sec              # [Seconds]\n\n#\n# Name of the parameter to enumerate, e.g. ESC index.\n# If the name is left empty, the node will infer the parameter name automatically (autodetect).\n# It is highly recommended to always use autodetection in order to avoid dependency on hard-coded parameter names,\n# and also allow the enumeratee to possibly enumerate multiple different parameters at once.\n# The rule of thumb is to always leave this parameter empty unless you really know what you're doing.\n#\nuint8[<=92] parameter_name\n\n---\n\nuint8 ERROR_OK                  = 0     # Success\nuint8 ERROR_INVALID_MODE        = 1     # The node cannot perform enumeration in its current operating mode\nuint8 ERROR_INVALID_PARAMETER   = 2     # The node cannot enumerate on the requested parameter, or it doesn't exist\nuint8 ERROR_UNSUPPORTED         = 3     # The node cannot perform enumeration in its current configuration\nuint8 ERROR_UNKNOWN             = 255   # Generic error\nuint8 error\n"
  },
  "380.Indication.uavcan": {
    "definition": "#\n# This message will be broadcasted when the node receives user input in the process of enumeration.\n#\n\nvoid6\n\n#\n# This field is unused; keep it empty\n#\nuavcan.protocol.param.NumericValue value\n\n#\n# Name of the enumerated parameter.\n# This field must always be populated by the enumeratee.\n# If multiple parameters were enumerated at once (e.g. ESC index and the direction of rotation),\n# the field should contain the name of the most important parameter.\n#\nuint8[<=92] parameter_name\n"
  },
  "40.BeginFirmwareUpdate.uavcan": {
    "definition": "#\n# This service initiates firmware update on a remote node.\n#\n# The node that is being updated (slave) will retrieve the firmware image file 'image_file_remote_path' from the node\n# 'source_node_id' using the file read service, then it will update the firmware and reboot.\n#\n# The slave can explicitly reject this request if it is not possible to update the firmware at the moment\n# (e.g. if the node is busy).\n#\n# If the slave node accepts this request, the initiator will get a response immediately, before the update process\n# actually begins.\n#\n# While the firmware is being updated, the slave should set its mode (uavcan.protocol.NodeStatus.mode) to\n# MODE_SOFTWARE_UPDATE.\n#\n\nuint8 source_node_id         # If this field is zero, the caller's Node ID will be used instead.\nPath image_file_remote_path\n\n---\n\n#\n# Other error codes may be added in the future.\n#\nuint8 ERROR_OK               = 0\nuint8 ERROR_INVALID_MODE     = 1    # Cannot perform the update in the current operating mode or state.\nuint8 ERROR_IN_PROGRESS      = 2    # Firmware update is already in progress, and the slave doesn't want to restart.\nuint8 ERROR_UNKNOWN          = 255\nuint8 error\n\nuint8[<128] optional_error_message   # Detailed description of the error.\n"
  },
  "45.GetInfo.uavcan": {
    "definition": "#\n# Request info about a remote file system entry (file, directory, etc).\n#\n\nPath path\n\n---\n\n#\n# File size in bytes.\n# Should be set to zero for directories.\n#\nuint40 size\n\nError error\n\nEntryType entry_type\n"
  },
  "46.GetDirectoryEntryInfo.uavcan": {
    "definition": "#\n# This service can be used to retrieve a remote directory listing, one entry per request.\n#\n# The client should query each entry independently, iterating 'entry_index' from 0 until the last entry is passed,\n# in which case the server will report that there is no such entry (via the fields 'entry_type' and 'error').\n#\n# The entry_index shall be applied to the ordered list of directory entries (e.g. alphabetically ordered). The exact\n# sorting criteria does not matter as long as it provides the same ordering for subsequent service calls.\n#\n\nuint32 entry_index\n\nPath directory_path\n\n---\n\nError error\n\nEntryType entry_type\n\nPath entry_full_path  # Ignored/Empty if such entry does not exist.\n"
  },
  "47.Delete.uavcan": {
    "definition": "#\n# Delete remote file system entry.\n# If the remote entry is a directory, all nested entries will be removed too.\n#\n\nPath path\n\n---\n\nError error\n"
  },
  "48.Read.uavcan": {
    "definition": "#\n# Read file from a remote node.\n# \n# There are two possible outcomes of a successful service call:\n#  1. Data array size equals its capacity. This means that the end of the file is not reached yet.\n#  2. Data array size is less than its capacity, possibly zero. This means that the end of file is reached.\n# \n# Thus, if the client needs to fetch the entire file, it should repeatedly call this service while increasing the\n# offset, until incomplete data is returned.\n#\n# If the object pointed by 'path' cannot be read (e.g. it is a directory or it does not exist), appropriate error code\n# will be returned, and data array will be empty.\n#\n\nuint40 offset\n\nPath path\n\n---\n\nError error\n\nuint8[<=256] data\n"
  },
  "49.Write.uavcan": {
    "definition": "#\n# Write into a remote file.\n# The server shall place the contents of the field 'data' into the file pointed by 'path' at the offset specified by\n# the field 'offset'.\n#\n# When writing a file, the client should repeatedly call this service with data while advancing offset until the file\n# is written completely. When write is complete, the client shall call the service one last time, with the offset\n# set to the size of the file and with the data field empty, which will signal the server that the write operation is\n# complete.\n#\n# When the write operation is complete, the server shall truncate the resulting file past the specified offset.\n#\n# Server implementation advice:\n# It is recommended to implement proper handling of concurrent writes to the same file from different clients, for\n# example by means of creating a staging area for uncompleted writes (like FTP servers do).\n#\n\nuint40 offset\n\nPath path\n\nuint8[<=192] data\n\n---\n\nError error\n"
  },
  "EntryType.uavcan": {
    "definition": "#\n# Nested type.\n# Represents the type of the file system entry (e.g. file or directory).\n# If such entry does not exist, 'flags' must be set to zero.\n#\n\nuint8 FLAG_FILE      = 1        # Excludes FLAG_DIRECTORY\nuint8 FLAG_DIRECTORY = 2        # Excludes FLAG_FILE\nuint8 FLAG_SYMLINK   = 4        # Link target is either FLAG_FILE or FLAG_DIRECTORY\nuint8 FLAG_READABLE  = 8\nuint8 FLAG_WRITEABLE = 16\n\nuint8 flags\n"
  },
  "EntryType": {
    "description": "Nested type.\nRepresents the type of the file system entry (e.g. file or directory).\nIf such entry does not exist, 'flags' must be set to zero.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "flags",
        "description": ""
      }
    ],
    "statics": [
      "uint8 FLAG_FILE      = 1        # Excludes FLAG_DIRECTORY",
      "uint8 FLAG_DIRECTORY = 2        # Excludes FLAG_FILE",
      "uint8 FLAG_SYMLINK   = 4        # Link target is either FLAG_FILE or FLAG_DIRECTORY",
      "uint8 FLAG_READABLE  = 8",
      "uint8 FLAG_WRITEABLE = 16"
    ]
  },
  "Error.uavcan": {
    "definition": "#\n# Nested type.\n# File operation result code.\n#\n\nint16 OK                = 0\nint16 UNKNOWN_ERROR     = 32767\n\nint16 NOT_FOUND         = 2\nint16 IO_ERROR          = 5\nint16 ACCESS_DENIED     = 13\nint16 IS_DIRECTORY      = 21 # I.e. attempt to read/write on a path that points to a directory\nint16 INVALID_VALUE     = 22 # E.g. file name is not valid for the target file system\nint16 FILE_TOO_LARGE    = 27\nint16 OUT_OF_SPACE      = 28\nint16 NOT_IMPLEMENTED   = 38\n\nint16 value\n"
  },
  "Error": {
    "description": "Nested type.\nFile operation result code.",
    "variables": [
      {
        "kind": "int",
        "bits": 16,
        "name": "value",
        "description": ""
      }
    ],
    "statics": [
      "int16 OK                = 0",
      "int16 UNKNOWN_ERROR     = 32767",
      "int16 NOT_FOUND         = 2",
      "int16 IO_ERROR          = 5",
      "int16 ACCESS_DENIED     = 13",
      "int16 IS_DIRECTORY      = 21 # I.e. attempt to read/write on a path that points to a directory",
      "int16 INVALID_VALUE     = 22 # E.g. file name is not valid for the target file system",
      "int16 FILE_TOO_LARGE    = 27",
      "int16 OUT_OF_SPACE      = 28",
      "int16 NOT_IMPLEMENTED   = 38"
    ]
  },
  "Path.uavcan": {
    "definition": "#\n# Nested type.\n#\n# File system path in UTF8.\n#\n# The only valid separator is forward slash.\n#\n\nuint8 SEPARATOR = '/'\n\nuint8[<=200] path\n"
  },
  "Path": {
    "description": "Nested type.\nFile system path in UTF8.\nThe only valid separator is forward slash.",
    "variables": [
      {
        "length": 200,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "path",
        "description": ""
      }
    ],
    "statics": [
      "uint8 SEPARATOR = '/'"
    ]
  },
  "10.ExecuteOpcode.uavcan": {
    "definition": "#\n# Service to control the node configuration.\n#\n\n#\n# SAVE operation instructs the remote node to save the current configuration parameters into a non-volatile\n# storage. The node may require a restart in order for some changes to take effect.\n#\n# ERASE operation instructs the remote node to clear its configuration storage and reinitialize the parameters\n# with their default values. The node may require a restart in order for some changes to take effect.\n#\n# Other opcodes may be added in the future (for example, an opcode for switching between multiple configurations).\n#\nuint8 OPCODE_SAVE  = 0  # Save all parameters to non-volatile storage.\nuint8 OPCODE_ERASE = 1  # Clear the non-volatile storage; some changes may take effect only after reboot.\nuint8 opcode\n\n#\n# Reserved, keep zero.\n#\nint48 argument\n\n---\n\n#\n# If 'ok' (the field below) is true, this value is not used and must be kept zero.\n# If 'ok' is false, this value may contain error code. Error code constants may be defined in the future.\n#\nint48 argument\n\n#\n# True if the operation has been performed successfully, false otherwise.\n#\nbool ok\n"
  },
  "11.GetSet.uavcan": {
    "definition": "#\n# Get or set a parameter by name or by index.\n# Note that access by index should only be used to retrieve the list of parameters; it is highly\n# discouraged to use it for anything else, because persistent ordering is not guaranteed.\n#\n\n#\n# Index of the parameter starting from 0; ignored if name is nonempty.\n# Use index only to retrieve the list of parameters.\n# Parameter ordering must be well defined (e.g. alphabetical, or any other stable ordering),\n# in order for the index access to work.\n#\nuint13 index\n\n#\n# If set - parameter will be assigned this value, then the new value will be returned.\n# If not set - current parameter value will be returned.\n# Refer to the definition of Value for details.\n#\nValue value\n\n#\n# Name of the parameter; always preferred over index if nonempty.\n#\nuint8[<=92] name\n\n---\n\nvoid5\n\n#\n# Actual parameter value.\n#\n# For set requests, it should contain the actual parameter value after the set request was\n# executed. The objective is to let the client know if the value could not be updated, e.g.\n# due to its range violation, etc.\n#\n# Empty value (and/or empty name) indicates that there is no such parameter.\n#\nValue value\n\nvoid5\nValue default_value    # Optional\n\nvoid6\nNumericValue max_value # Optional, not applicable for bool/string\n\nvoid6\nNumericValue min_value # Optional, not applicable for bool/string\n\n#\n# Empty name (and/or empty value) in response indicates that there is no such parameter.\n#\nuint8[<=92] name\n"
  },
  "Empty.uavcan": {
    "definition": "#\n# Ex nihilo nihil fit.\n#\n"
  },
  "Empty": {
    "description": "Ex nihilo nihil fit.",
    "variables": [],
    "statics": []
  },
  "NumericValue.uavcan": {
    "definition": "#\n# Numeric-only value.\n#\n# This is a union, which means that this structure can contain either one of the fields below.\n# The structure is prefixed with tag - a selector value that indicates which particular field is encoded.\n#\n\n@union                          # Tag is 2 bits long.\n\nEmpty empty                     # Empty field, used to represent an undefined value.\n\nint64   integer_value\nfloat32 real_value\n"
  },
  "NumericValue": {
    "description": "Numeric-only value.\nThis is a union, which means that this structure can contain either one of the fields below.\nThe structure is prefixed with tag - a selector value that indicates which particular field is encoded.",
    "variables": [
      {
        "kind": "int",
        "bits": 64,
        "name": "integerValue",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "realValue",
        "description": ""
      }
    ],
    "statics": []
  },
  "Value.uavcan": {
    "definition": "#\n# Single parameter value.\n#\n# This is a union, which means that this structure can contain either one of the fields below.\n# The structure is prefixed with tag - a selector value that indicates which particular field is encoded.\n#\n\n@union                          # Tag is 3 bit long, so outer structure has 5-bit prefix to ensure proper alignment\n\nEmpty empty                     # Empty field, used to represent an undefined value.\n\nint64        integer_value\nfloat32      real_value         # 32-bit type is used to simplify implementation on low-end systems\nuint8        boolean_value      # 8-bit value is used for alignment reasons\nuint8[<=128] string_value       # Length prefix is exactly one byte long, which ensures proper alignment of payload\n"
  },
  "Value": {
    "description": "Single parameter value.\nThis is a union, which means that this structure can contain either one of the fields below.\nThe structure is prefixed with tag - a selector value that indicates which particular field is encoded.",
    "variables": [
      {
        "kind": "int",
        "bits": 64,
        "name": "integerValue",
        "description": ""
      },
      {
        "kind": "float",
        "bits": 32,
        "name": "realValue",
        "description": "32-bit type is used to simplify implementation on low-end systems"
      },
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "booleanValue",
        "description": "8-bit value is used for alignment reasons"
      },
      {
        "length": 128,
        "range": true,
        "kind": "intArray",
        "unsigned": true,
        "bits": 8,
        "name": "stringValue",
        "description": "Length prefix is exactly one byte long, which ensures proper alignment of payload"
      }
    ],
    "statics": []
  },
  "2010.Broadcast.uavcan": {
    "definition": "#\n# This message struct carries arbitrary data in the format of the specified high-level protocol.\n# The data will be delivered to all nodes that are interested in tunneled protocols.\n# Finer addressing schemes may be implemented using the means provided by the encapsulated protocol.\n# The channelID allows for additional routing between the source and target nodes.\n\nProtocol protocol\nuint8 channel_id\n\nuint8[<=60] buffer    # TAO rules apply\n"
  },
  "63.Call.uavcan": {
    "definition": "#\n# This service carries arbitrary data in the format of the specified high-level protocol.\n# The data will be delivered to the specified node only (not broadcast), and the addressed node\n# will be required to respond (although the response may be empty, if the chosen protocol allows so).\n# The specified protocol applies both to the request and to the response. The channelID allows for\n# additional routing between the source and target nodes.\n#\n\nProtocol protocol\nuint8 channel_id\n\nuint8[<=60] buffer    # TAO rules apply\n\n---\n\nuint8[<=60] buffer    # TAO rules apply\n"
  },
  "Protocol.uavcan": {
    "definition": "#\n# This enumeration specifies the encapsulated protocol.\n# New protocols are likely to be added in the future.\n#\n\nuint8 MAVLINK                   = 0     # MAVLink\n\nuint8 protocol\n"
  },
  "Protocol": {
    "description": "This enumeration specifies the encapsulated protocol.\nNew protocols are likely to be added in the future.",
    "variables": [
      {
        "kind": "int",
        "unsigned": true,
        "bits": 8,
        "name": "protocol",
        "description": ""
      }
    ],
    "statics": [
      "uint8 MAVLINK                   = 0     # MAVLink"
    ]
  }
}